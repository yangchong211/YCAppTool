# 定时重启App工具库
#### 目录介绍
- 01.基础概念介绍
- 02.常见思路和做法
- 03.Api调用说明
- 04.遇到的坑分析
- 05.其他问题说明



### 01.基础概念说明
#### 1.1 业务背景介绍
- 在App开发过程中，经常需要自动重启的功能。比如：
    - 登录或登出的时候，为了清除缓存的一些变量，比较简单的方法就是重新启动app。
    - crash的时候，可以捕获到异常，直接自动重启应用。
    - 在一些debug的场景中，比如设置了一些测试的标记位，需要重启才能生效，此时可以用自动重启，方便测试。
- 还有一些特殊的场景，比如一些硬件设备：
    - 由于App是launcher应用，长期运行在硬件设备上，除了做内存优化之外。有时候需要在夜间某时间重启，可以解决一些体验上问题！


#### 1.2 为何设置定时重启



### 02.常见思路和做法
#### 2.1 常见自动重启方式
- 方式1: AlarmManager
    - 使用AlarmManager实现自动重启的核心思想：创建一个100ms之后的Alarm任务，等Alarm任务到执行时间了，会自动唤醒App。
    - 缺点：在App被杀和拉起之间，会显示系统Launcher桌面，体验不好。在高版本不适用
- 方式2: 直接启动Activity
    - 缺点：MainActivity必须是Standard模式
- 方式3: 启动新进程开启应用
    - 简单来说，当调用重启app后进入首页方法的时候，会启动一个透明的Activity，这个Activity运行在:reboot 进程
    - Activity启动后，杀掉主进程，然后用:reboot 进程拉起主进程的Activity。关闭当前Activity，杀掉:reboot 进程



#### 2.3 新进程开启应用原理
- 新进程开启应用原理大概如下所示，可以做到无缝启动应用！
    - 启动一个新的进程。相当于通过intent开启一个透明的activity，并且给它开启一个独立的进程。
    - 杀掉主进程。在这个透明的activity中，杀死原来的主进程。
    - 用新的进程，重新拉起主进程。然后拿到要启动的intent，其实这个就是清单文件配置默认启动activity的intent。
    - 杀掉新的进程。最后通过Runtime杀死主进程！



### 03.Api调用说明



### 04.遇到的坑分析
#### 4.1 新进程开启应用注意
- 因为开启了新进程，导致初始化多次
    - 通常会在Application的onCreate方法中做一系列初始化的操作。
    - 如果使用reboot库，需要在onCreate方法中判断，如果当前进程是reboot进程，则直接return，跳过初始化的操作。
- 如下所示：
    ```
    if (RebootManager.getInstance().isRebootProcess(this)) {
        return;
    }
    ```



### 05.其他问题说明


#### 5.3 参考博客连接


