#### 目录介绍
- 01.什么是哈希算法
- 02.哈希算法的应用
- 03.安全加密的场景
- 04.唯一标识
- 05.数据校验
- 06.散列函数
- 07.哈希算法总结





### 01.什么是哈希算法
- 哈希算法历史悠久
    - 业界著名的哈希算法也很多，比如MD5、SHA等。在平时的开发中，基本上都是拿现成的直接用。今天不会重点剖析哈希算法的原理，也不会教你如何设计一个哈希算法，而是从实战角度告诉你，在实际开发中，我们该如何用哈希算法解决问题。
- 什么是哈希算法，用一句话就可以概括了。
    - 将任意长度的二进制值串映射为固定长度的二进制值串，这个映射规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。
- 但是，要设计一个优秀的哈希算法并不容易，我了需要满足的几点要求：
    - 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
    - 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；
    - 散列总被的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
    - 哈希算法的执行效率尽量高效，针对较长的文本，也能快速计算出哈希值。
- 拿MD5这种哈希算法具体说明下，比如计算这两个文本的MD5哈希值——“今天我来讲哈希算法”、“jiajia"。得到的两串毫无规律的字符串（MD5的哈希值是128位的Bit长度，便于表示，转化为16进制编码）。可以看出，无论文本的长度是多少，得到的哈希值长度是相同的，而且看起来像一堆随机数，完全没有规律。
    ```
    MD5("今天我来讲哈希算法") = bb4767201ad42c74e650c1b6c03d78fa
    MD5("jiajia") = cd611a31ea969b908932d44d126d195b
    ```
- 试试两个很相似的文本，虽然只有一个标点的差别，但哈希值是完全不相同的。同时根据哈希值，是很难反向推导出原始数据。
    ```
    MD5("我今天讲哈希算法！") = 425f0d5a917188d2c3c3dc85b5e4f2cb
    MD5("我今天讲哈希算法 ")  = a1fb91ac128e6aa37fe42c663971ac3d
    ```
- 哈希算法要处理的文本可能是各种各样的。
    - 比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际软件开发中。
    - 比如，把今天的这篇包含4000多个汉字的文章，用MD5计算哈希值，用不了1ms的时间。



### 02.哈希算法的应用
- Hash有哪些流行的算法
    - 目前流行的 Hash 算法包括 MD5、SHA-1 和 SHA-2。
- 哈希算法主要有哪些
    - MD5算法：MD5，MD5+盐
    - SHA算法：包含5个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512，后四者并称为SHA-2。
- 哈希算法的应用非常非常多，选了最觉的七个
    - 分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。



### 03.安全加密的场景
- 说到哈希算法的应用，最先想到的应该是安全加密。
    - 最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他的加密方法，比如DES（Advance Encryption Standard，高级加密标准）。
- 对用于加密的哈希算法来说，有两点很重要：第一是很难根据哈希值反向推导出原始数据，第二是散列冲突的概率要很小。
    - 第一点很好理解，加密的目的就是不会后悔原始数据泄露，所以很难通过哈希值反向推导出原始以数据，这是一个基本要求。
    - 重点说说第二点，但不管什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的，这是为什么呢？
- 基于组合数学中一个叛党基础的理论，鸽巢原理（也叫抽屉原理）。
    - 这个原理本身很简单，它是说，如果有10个鸽巢，有11只鸽子，那肯定有1个鸽巢中的鸽子数量大于1，换句话说就是，肯定有一个巢里的鸽子数量大于1。
    - 哈希算法产生的哈希值的长度是固定且有限的。比如前面说的MD5的鸽子，哈希值是固定的128位二进制串，能表示的数据是有限的，最多表示2^128个数据，而我们要哈希的数据可以是无穷的，那必然会存在哈希值相同的情况。
    - 如果我们拿到一个MD5哈希值，希望通过毫无规律的穷举的方法，找到这个MD5值相同的另一个数据，那耗费的时间应该是个天文数字了。即便哈希算法理论上存在冲突，但还是很难破解的。
- 除此之外，**没有绝对安全的加密**。
    - 越复杂、越难破解的加密算法，需要的计算时间也越长。比如SHA-256比SHA-1要更复杂、更安全，相应的计算时间就会比较长。



### 04.唯一标识
- 先举个例子。如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来对比，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢？
- 任何文件在计算机中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串逐一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十KB、大则几MB,转化成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？
- 可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片二进制码串开关取100个字节，从中间取100个字节，从最后取100个字节，然后将这300个字节放一块。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。
- 如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个标识。
- 如果不存在，那就说明这个图片不在图库中，如果存在，我们再通过散列表存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样，如果一样，就说明已经存在；如果一一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。



### 05.数据校验
- 电驴这样的BT下载软件听过吧！我们知道，BT下载的原理是基石地P2P协议的。我们从多个机器上并行下载一个2GB的电影，这个电影文件可能会被分割成很多文件块（比如可以分成100块，每块大约200MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。
- 我们知道，网络传输是不安全的，下载的文件块有可能是被宿主机恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？
- 具体的BT协议很复杂，校验方法也有很多，我来说其中的一种思路。我们通过哈希算法，对100个文件块分别取哈希值，并且保存种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机上下载这个文件块。


### 06.散列函数
- 散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便是出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。
- 不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀的散列到各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，能以，散列函数用的散列算法一般都比较简单，比较追求效率。




### 07.哈希算法总结
- 第一个应用是唯一标识，哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。
- 第二个应用是校验数据的完整性和正确性。
- 第三个应用是安全加密，我们讲到任何哈希算法都会出现散列冲突，但是这个冲突的概率非常小。越是复杂的哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。
- 第四个应用是散列函数，这个我们前面讲散列表的时候详细说过，它对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。















