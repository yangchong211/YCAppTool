#### 目录介绍
- 01.整体概述
    - 1.1 项目背景说明
    - 1.2 技术方案选型
    - 1.3 基础概念介绍
    - 1.4 开发设计目标
- 02.通信基础概念
    - 2.1 Socket基础理解
    - 2.2 TCP/IP协议简介
    - 2.3 Socket与Http对比
    - 2.4 Socket的使用类型
    - 2.5 Socket和ServerSocket
- 03.Socket实践思路
    - 3.1 基础实践步骤
    - 3.2 Socket连接
    - 3.3 Socket中tls连接
    - 3.4 Socket数据读写
    - 3.5 Socket断开连接
    - 3.6 Socket完整案例
    - 3.7 Socket多线程应用
- 04.通信实践设计
    - 4.1 设计Tcp初始化
    - 4.2 设计Tcp监听
    - 4.3 设计Tcp发送
    - 4.4 断开重试的设计
    - 4.5 TcpPacket设计
    - 4.6 如何设计长链接
    - 4.7 数据的封包和解析
    - 4.8 一些注意点
- 05.方案设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.稳定性实践说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
    - 6.6 安全性设计
- 07.TCP/IP精髓设计
    - 7.1 协议版本如何升级
    - 7.2 如何发送不定长数据的数据包
    - 7.3 如何保证数据有序性
    - 7.4 UDP传输数据可靠





### 00.问题汇总说明
- Socket概念：Socket是如何通信的？跟Http有何区别？数据传递性能如何？是否具有安全性？
- Socket实践：Socket是如何使用的的？如何创建连接，读数据（接受）和写数据（发送）分别是怎么设计的？
- Socket实践：读数据的时候，如何将io字节流转化为特定的tcp数据，拿到tcp数据后如何解析数据(解析成对应实体bean)？
- Socket长链接：如何设置socket保持长链接？如何保持轮训心跳包稳定性并且不会阻塞主线程？如何理解心跳包？
- Socket读写：如何理解Socket读写数据？如何处理读写异常逻辑？异常之后如何设计重新连接？
- Socket数据：TcpPacket是如何设计的？消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界？
- Socket数据：如何保证数据有序性？一个任务队列，执行任务，如何保证先取出的任务，执行结果需要先放入结果队列？
- Socket传输：UDP传输数据，怎么数据是可以靠的




### 01.整体概述
#### 1.1 项目背景说明


#### 1.2 技术方案选型
- 类似微信消息接收等场景
    - 方案1：需要客户端主动去轮询，则会频繁发起请求，对于服务器会产生很大的负载压力，浪费带宽流量。
    - 方案2：通过长连接，服务端可以主动把消息下发给客户端，做到最高实时性，且节省流量。


#### 1.3 基础概念介绍


#### 1.4 开发设计目标


### 02.通信基础概念
#### 2.1 Socket基础理解
- Socket定义
    - 即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。
- 核心要点
    - Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）
    - 通过Socket，我们才能在Android平台上通过 TCP/IP协议进行开发；对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信。


#### 2.2 TCP/IP协议简介
- IP
    - IP 协议提供了主机和主机间的通信。为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的IP地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。
- TCP
    - TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。
- Port
    - 为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的端口号。


#### 2.3 Socket与Http对比
- 不属于同一层面
    - Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题
    - HTTP协议 属于 应用层，解决的是如何包装数据
- 工作方式的不同
    - Http：采用 请求—响应 方式。可理解为：是客户端有需要才进行通信；
    - Socket：采用 服务器主动发送数据 的方式。可理解为：是服务器端有需要才进行通信



#### 2.4 Socket的使用类型
- Socket的使用类型主要有两种：
    - 流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务
    - 数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务
- 具体原理图如下：
    - ![image](https://img-blog.csdnimg.cn/f030fc846dbe4154a4806093d8209b42.png)



#### 2.5 Socket和ServerSocket
- Socket 和 ServerSocket 的区别是什么
    - 在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 ServerSocket 和用于通信的 Socket。



### 03.Socket实践思路
#### 3.1 基础实践步骤
- Socket可基于TCP或者UDP协议，但TCP更加常用。所以下面的使用步骤 & 实例的Socket将基于TCP协议。
    - 第一步：创建客户端 & 服务器的连接。
    - 第二步：客户端 & 服务器 通信。
    - 第三步：断开客户端 & 服务器 连接。


#### 3.2 Socket连接
- 第一步：创建客户端 & 服务器的连接。创建Socket对象 & 指定服务端的IP及端口号 ，判断客户端和服务器是否连接成功。
    ``` java
    // 创建Socket对象 & 指定服务端的IP及端口号 
    Socket socket = new Socket("192.168.1.32", 1989);  
    // 判断客户端和服务器是否连接成功  
    socket.isConnected();
    ```
- Socket连接条件
    - 需要指定ip地址和port端口号。然后调用`socket?.connect(address, timeOut)`


#### 3.3 Socket中tls连接
- 这一步的作用主要是：增加安全性校验。


#### 3.4 Socket数据读写
- 第二步：客户端 & 服务器 通信。通信包括：客户端 接收服务器的数据 & 发送数据到服务器
    ```
    <-- 操作1：接收服务器的数据 -->
    // 步骤1：创建输入流对象InputStream
    InputStream is = socket.getInputStream() 
    // 步骤2：创建输入流读取器对象 并传入输入流对象
    // 该对象作用：获取服务器返回的数据
    InputStreamReader isr = new InputStreamReader(is);
    BufferedReader br = new BufferedReader(isr);
    // 步骤3：通过输入流读取器对象 接收服务器发送过来的数据
    br.readLine()；
    
    <-- 操作2：发送数据 到 服务器 -->                  
    // 步骤1：从Socket 获得输出流对象OutputStream
    // 该对象作用：发送数据
    OutputStream outputStream = socket.getOutputStream(); 
    // 步骤2：写入需要发送的数据到输出流对象中
    outputStream.write（（"杨充"+"\n"）.getBytes("utf-8")）；
    // 特别注意：数据的结尾加上换行符才可让服务器端的readline()停止阻塞
    // 步骤3：发送数据到服务端 
    outputStream.flush();  
    ```


#### 3.5 Socket断开连接
- 第三步：断开客户端 & 服务器 连接
    ```
    // 断开 客户端发送到服务器 的连接，即关闭输出流对象OutputStream
    os.close();
    // 断开 服务器发送到客户端 的连接，即关闭输入流读取器对象BufferedReader
    br.close();
    // 最终关闭整个Socket连接
    socket.close();
    ```


#### 3.6 Socket完整案例
- TCP Socket分为Socket和ServerSocket对应着client和server，下面我来用代码实现一个简单的TCP通讯功能：
- 客户端：首先创建一个Socket和InetSocketAddress，然后通过Socket的connect()方法进行连接，连接成功后可以获取到输出流，通过该输出流就可以向服务端传输数据。
    ```
    public class TCPClient {
        public static void main(String[] args) throws IOException {
            //1.创建TCP客户端Socket服务
            Socket client = new Socket();
            //2.与服务端进行连接
            InetSocketAddress address = new InetSocketAddress("192.168.31.137",10000);
            client.connect(address);
            //3.连接成功后获取客户端Socket输出流
            OutputStream outputStream = client.getOutputStream();
            //4.通过输出流往服务端写入数据
            outputStream.write("hello server".getBytes());
            //5.关闭流
            client.close();
        }
    }
    ```
- 服务端：创建一个服务端Socket并明确端口号，通过accept()方法获取到链接过来的客户端Socket，从客户端Socket中获取输入流，最后由输入流读取客户端传输来的数据。
    ```
    public class TCPServer {
        public static void main(String[] args) throws IOException {
            //1.创建服务端Socket并明确端口号
            ServerSocket serverSocket = new ServerSocket(10000);
            //2.获取到客户端的Socket
            Socket socket = serverSocket.accept();
            //3.通过客户端的Socket获取到输入流
            InputStream inputStream = socket.getInputStream();
            //4.通过输入流获取到客户端传递的数据
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            String line = null;
            while ((line = bufferedReader.readLine())!=null){
                System.out.println(line);
            }
            //5.关闭流
            socket.close();
            serverSocket.close();
        }
    }
    ```
- 一个服务端是可以同时和多个客户端进行通信的，那么它是如何区分不同客户端呢？
    - 从上面代码我们可以看到，服务端首先通过accept()获取到客户端Socket，然后通过客户端的Socket获取的流进行通讯，这也让服务端得以区分每个客户端。



#### 3.7 Socket多线程应用
- 如何是阻塞线程？
    - 参考OkHttp的分发器



### 04.通信实践设计
#### 4.1 设计Tcp初始化
- 设计Tcp初始化的代码如下所示
    ```
    TcpFacade.putExtra(TcpFacade.UDID, "E1274F3EF737603D08FE758455F67AF9|0")
        .setDynamicInfoDelegate { key ->
            when (key) {
                TcpFacade.TOKEN -> "token"
            }
        }
        .setDisableTcpOnBackGround(false)
        .setTrustManagerProvider(TrustManagerProviderUnSafe())
        .init(this)
    ```
- TCP注册干了啥
    - 传递了一些参数，比如用户token，uid，版本号，用户 secret。主要是客户端和服务端通信需要的一些关键参数。
- Tcp初始化的流程图如下所示
    - ![image](https://img-blog.csdnimg.cn/8a67646577144160bb94e2f5aa185f57.png)




#### 4.2 设计Tcp监听
- 设计Tcp监听的代码如下所示
    ```
    TcpFacade.registerTcpMessage(this) { tcpMessage ->
        AppLogUtils.d("registerTcpMessage:${it}")
        when (tcpMessage) {
            is TcpCommonDialog -> {
                //出事消息
            }
        }
    }
    ```
- TCP添加监听消息流程图
    - ![image](https://img-blog.csdnimg.cn/a288c472b5804e8c9207991961ab8c20.png)



#### 4.3 设计Tcp发送
- 设计Tcp监听的代码如下所示
    ```
    TcpFacade.getTcpManager().sendCall(
        TcpLogin(token = token,uid = uid)
    )
    ```




#### 4.4 断开重试的设计
- 长连接何时会断开
    - 正常而言，长连接是不会断开的。大家可以自己试一试，两个socket建立连接，只要网络不变、一切正常，那么这两个socket可以一直互相传送数据，不会断开。
    - 但是，在移动网络下，网络状态复杂多变，比如线路异常，网络线路被切断、服务器宕机等，都会导致长连接中断。
- 需要关注下面几个长连接断开原因：
    - 1.长连接所在进程被杀。这个很容易理解，如果App切换到后台，那么系统随时可能将我们的App杀掉，这时长连接自然也就随之断开。
    - 2.用户切换网络。比如手机网络断开，或者发生Wi-Fi和蜂窝数据切换，这时会导致手机IP地址变更。TCP连接是基于IP + Port的，一旦IP变更，TCP连接自然也就失效了，或者说长连接也就相当于断开了。
    - 3.系统休眠等导致NAT超时。运营商会给每台设备分配一个公网IP。随着连接网络的设备不断增多，网关负载也会不断加大，这时运营商会对一些不太活跃设备进行公网IP回收，如果下次这个设备需要连网，那就重新分配一个IP即可。
    - 4.DHCP 租期过期。如果没有及时续约，同样会导致IP地址失效。
    - 综合而言：长连接在正常情况下是不会断开的，但是，一旦手机的IP地址失效，这时就不得不重新建立连接了。
- 断开重连的方案设计
    - 创建Receiver，监控网络状态，如果网络发生切换则立即重连；
    - 监控服务端心跳包回包，如果连续5次没有收到回包，则认为长连接已经失效；
    - 设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电；
    - 等socket IO异常抛出，不过耗时太长，需要15s左右才能发现。





#### 4.5 数据的封包和解析
- 如何解析数据
    - 将二进制数据转化为实体packet数据。
- 如何封包数据
    - 组装packet数据体，然后将数据转化为io流二进制数据。




#### 4.6 如何设计长链接
- Socket 长连接的实现背景知识
    - Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。
- 先来思考一个问题
    - 假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用。
    - 1.某一端关闭是 socket（这不是废话吗）。主动关闭的一方会发送 FIN，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 EoF（End of File）。于是我们知道对方关闭了 socket。
    - 2.应用程序奔溃。此时 socket 会由内核关闭，结果跟情况1一样。
    - 3.系统奔溃。这时候系统是来不及发送 FIN 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。
    - 4.电缆被挖断、网线被拔。跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。
- 如何设计长链接
    - 要实现一个socket长连接，需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的心跳。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。
    - 首先会每隔1分钟，客户端就给服务端对方发送一个 ping 包，看看对面在不在，服务端则回执 pong 包表示回应。如果超过2分钟秒还没有回复我，那就说明对方掉线了，关闭这边的 TCP 端。
- 轮训发送ping作用
    - 客户端发送ping【无业务互动时】，而且还是一个轮训的，主要是保持长链接通畅。
- 服务端发送pong包
    - server端发送心跳pong包，主要是回应客户端信息【回复ping消息】。
- 客户端如何保证消息轮训处理且不会阻塞主线程【场景是：频繁处理消息】
    - 使用独享的Looper(HandlerThread)。处理异步任务的方式和 Thread + Looper + Handler 方式相同。内部实现了普通线程的 Looper 消息循环，不会阻塞UI县城。





#### 4.7 数据的封包和解析
- Tcp发送消息体【App发送tcp消息】
    - 将消息组装成 TcpPacket 结构体，然后发送出去。需要注意：发送的消息体需要转化为字符串，然后再转化为byte字节
    ```
    TcpPacket(privateTag = TcpLogin_1656059681564,length = 157,version = 1,type = LOGIN(80),data:{"app_version":"2.3.0","device_type":1,"sig":"085494bfd8586f3b22d6725bec51556b","stamp":1656059681551,"token":"","udid":"56A58B4C989DDCF083F200F078A324B5|0"})
    TcpPacket(privateTag = TcpPing_1656059681611,length = 2,version = 1,type = HEART_BEAT_PING(1),data:{})
    ```
- Tcp接收消息体【App接收tcp消息】
    ```
    TcpPacket(privateTag = 0_1656059681622,length = 58,version = 1,type = TCP_ERROR(0),data:{"type":80,"error_code":6,"error_msg":"缺少参数token"})
    TcpPacket(privateTag = 2_1656059681653,length = 0,version = 1,type = HEART_BEAT_PONG(2),data:)
    ```
- 设计的TcpPacket数据包体
    - privateTag，tcp唯一标示，主要是类型和时间戳拼接成的tag字符串
    - length，tcp长度，这个主要是指data的长度
    - version，版本
    - type，类型，用来区分一级消息类型
    - data，数据，一个json对象
    ``` kotlin
    data class TcpPacket(
        var privateTag: String,
        val length: Int = 0,
        val version: Byte = TcpConfig.TCPVersion,
        val type: Int,
        val payload: ByteArray
    ) 
    ```


#### 4.8 一些注意点
- 实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作。


### 05.方案设计
#### 5.1 整体架构图


#### 5.2 UML设计图


#### 5.3 关键流程图


#### 5.4 接口设计图


#### 5.5 模块间依赖关系


### 06.稳定性实践说明
#### 6.1 性能设计
- 关于长链接心跳包优化【固定心跳】
    - 如果想节省资源，在有客户发送数据的时候可以省略 heart beat。目前的做法是发送数据的时候，更新发送ping【移除之前的ping消息，然后发送一条最新的延迟ping消息】
- 优化使用智能心跳策略【动态心跳】
    - 在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少App因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。
    - 第一种：自适应心跳。第二种：前后台策略。
- 自适应心跳的设计
    - 首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此采用自适应心跳：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。
    - 如何判断一个心跳间隔有效呢？采用方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。
    - 探测过程大致为：60秒短心跳，连续发3次后开始探测，三次成功则改为90，依次类推120，150，180，210，240，270。
- 前后台策略的设计
    - 考虑到App在前后台对于长连接的需求是不同的。
    - 1.当App在前台活跃态时，采用了固定心跳机制；
    - 2.当前台熄屏态或者后台活跃态（进入后台10分钟内）时，先用几次最小心跳维持长连接，然后进入自适应心跳机制；
    - 3.当后台稳定态（超过10分钟），则采用自适应心跳计算出来的最大心跳作为固定值。



#### 6.2 稳定性设计
- 如何建立稳定长连接
    - 上面提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？
    - 第一种：长连接独立进程。将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。
    - 第二种：心跳机制。对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。需要通过心跳机制来保证App的活跃度，防止发生 NAT 超时导致断开连接。
    - 第三种：断开重连。在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要尽快发现长连接断开，并立即重连。



#### 6.3 灰度设计



#### 6.4 降级设计
- 长连接通道建设及容灾
    - 客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器IP就近接入；
    - 长连接建立好后，客户端对要发送的二进制数据进行加密并传输；
    - 代理服务器收到后，可以通过内部专线或普通Http请求来访问业务服务器；
    - 如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通Http短连或者UDP通道。



#### 6.5 异常设计
- 如何处理读写异常逻辑？
    - 对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。
    - 实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。



#### 6.6 安全性设计
- 长连接数据协议及加密
    - 长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如SMTP、ProtoBuf等序列化方案。
    - 在数据加密方面，可以结合非对称加密算法RSA和对称加密算法AES来对数据进行加密传输。



### 07.TCP/IP精髓设计
#### 7.1 协议版本如何升级
- 当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？
    - 答案可以在 IP 协议找到。IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。
    - 再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。



#### 7.2 如何发送不定长数据的数据包
- 举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？
    - 第一种：IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。
    - 第二种：那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 \0 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 \0。此时，我们就需要对用户的数据进行转义。比方说，把用户数据的所有 \0 都变成 \0\0。读消息的过程总，如果遇到 \0\0，那它就代表 \0，如果只有一个 \0，那就是消息尾部。
- 两种方案优缺点分析
    - 第一种使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。
    - 第二种终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。
    - 当然，这两个方法不是互斥的，可以一起使用。



#### 7.3 如何保证数据有序性
- 曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。
    - 先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。
- 看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。
- 一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。
- 更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能：
    - 刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。
    - 所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。
    - 如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。


#### 7.4 UDP传输数据可靠
- 模拟tcp



