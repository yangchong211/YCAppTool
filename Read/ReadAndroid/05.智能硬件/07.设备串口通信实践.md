#### 目录介绍
- 01.串口通信的方案
- 02.方案的对比分析
- 03.串口通信的方案
- 04.USB通信的方案





### 01.串口通信的方案
- 通信方案
  - USB Socket通信和串口通信。每一种方式都有自己的设备限制和场景限制。



### 02.方案的对比分析
- 串口通信：
    - 优点：1、不管是PC还是Android设备，串口都是默认支持的通用口，通用性强。2、无需高危权限，默认就能双向通信，更加安全。3、两根线就能完成通信，成本低廉。
    - 缺点：1、传输数据限制：数据帧的大小限制为最多 9 位，常用与ASCII编码，最多可以给256个字符(包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值。
    - 2、不支持2字节编码(中文编码等)：比如GB2312、GBK、Unicode、UTF-8等。
    - 3、不支持一对多：串口通信只支持一个主系统和一个从系统之间的通信。
    - 4、通信效率低：通信速率由波特率决定，速度效率是比较低的。
- USB通信：
    - 优点：1、高速传输，速度快。2、传输数据为字节级，可灵活转换适配各种编码方式。
    - 缺点：1、走USB Socket通信，需要开启USB调试，设备安全性大大降低。
- 方案选择
    - 从安全的角度考虑，更偏向于串口通信，虽然串口通信不是高速传输，但是对于我们的业务场景，100ms内能完成数据交互，用户体验几乎可以忽略不计，这个串口通信就能做到。




### 03.串口通信的方案
#### 3.1 理解串口协议
- 什么是串口协议？
    - 串口通信的概念非常简单，串口按位（bit）发送和接收字节。可能还是比较抽象，我们以上图为例通俗一点介绍。
    - 比如字符串‘L’，对应的二进制是01001100，串口通信就是通过串口线，将字符串‘L’以二进制的方式按位串行传输，传输速率就是双方规定的波特率。
    - 在我们的串口线里面有一个芯片，里面包含着一个硬件数据接收缓冲区，用来缓存发送端发来的数据。就好比一个水池，用来聚集上流的水源，下流的人按照一定的频率定时来取水。
- 假设我们的需求是：每次来都取走全部的数据。
    - 一个完整的包是‘LOL’，理想的情况下我们最想每次来都能拿到完整的数据。
    - 但是如上图所以，我们来取数据的时候存在各种情况，如‘OL’，‘LOL’，‘OLLOL’，‘LOLLOL’，就是所谓的数据‘分包’和‘粘包’。
    - 针对这两种场景，我们如何正确的从里面拆分以及整合出正确的包数据呢？


#### 3.2 建立应用缓冲区
- 分包和粘包终极解决方案就是建立应用缓冲区，将串口硬件缓冲区的数据按照顺序存进应用缓冲区，然后再按照一定的规则，将这一串数据，按照一个一个包切出来。
- 那么问题来了，如何定义这个包数据规则以及如何高效绝对可用的将数据切出来呢？



#### 3.3 通信包结构
- 完整的包结构包含：包头、包ID、包类型、目标数据长度、目标数据以及包尾校验位。
    - 包头：固定的16进制0x5A。
    - 包ID：每个数据包唯一的ID。
    - 包类型：规定数据包具体是做什么的。
    - 目标数据长度：目标数据的真实长度。
    - 目标数据：最终需要携带的数据。
    - 包完整校验：验证前面的数据是否是完整的。
- 以电子工卡支付一张夜宵劵为例子，我们的目标数据是：030000000200000000010000000201，代表的是晚餐消费，支付一张夜宵劵，夜宵劵抵扣金额是2分，扣取的现金是0元。具体的包结构如下：
    - 5A 625B 01A2 000F 03 00000002 00000000 01 00000002 01 96
    - 5A是包头；625B是包ID；01A2是扣费命令；000F是包长度；03是晚餐；00000002是总金额2分；00000000扣现金0元；01是一张券；00000002是券抵扣2分；01是模式1；96是校验
- 如何处理包的正常读取
    - 如果接收到的数据包不够，那么先不处理，等到数据包足够，再以5A为起始位，按照包长度截取指定长度的数据包，再通过包尾校验位计算数据是否完整。
    - 如果数据包完整的话那么这个包取出来，开始取下个包。如果数据包不完整，则寻找下一个5A，前面不完整的数据直接抛弃。
    - 这样就能保证每次都能取到正确的数据包，异常数据包丢弃，不会影响到下个数据包的正常读取。




### 04.USB通信的方案
#### 4.3 基于Socket通信
- Socket通信的优点
    - 1、传输数据支持多种编码：传输数据为字节级，可灵活转换适配各种编码方式。
    - 2、支持一对多：基于Socket通信，支持一对多，后期扩展性强。
    - 3、速度快：传输时间短，速度快，性能高。
- Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）
    - 通过Socket，我们才能使用TCP/IP协议来发送数据和接收数据。
    - 如果是在一台电脑上运行两个程序，只要写死IP为127.0.0.1，端口选择一个合适的就可以进行通信。
- 但是实际场景有点不一样
    - 因为一台是PC，另外一台是Android机具，在断网的情况下怎么通过一根USB线介质，实现Socket双向通信？adb forward tcp:1111 tcp:2222
    - 顾名思义，adb forward的功能是建立一个转发，adb forward tcp:11111 tcp:22222的意思是，将PC端的11111端口收到的数据，转发给到手机中22222端口。
    - 但是光执行这个命令还不能转发数据，还需要完成两个步骤才能传数据。这两个步骤是：
        - 1、在手机端，建立一个端口为22222的server，并打开server到监听状态。
        - 2、在PC端，建立一个socket client端，连接到端口为11111的server上。


#### 4.4 TCP粘包/拆包
- TCP编程底层都有粘包和拆包机制，因为我们在C/S这种传输模型下，以TCP协议传输的时候，在网络中的byte其实就像是河水，TCP就像一个搬运工,将这流水从一端转送到另一端，这时又分两种情况：
    - 1、如果客户端的每次制造的水比较多，也就是我们常说的客户端给的包比较大，TCP这个搬运工就会分多次去搬运。
    - 2、如果客户端每次制造的水比较少的话，TCP可能会等客户端多次生产之后，把所有的水一起再运输到另一端。
    - 上述第一种情况，就是需要我们进行粘包，在另一端接收的时候，需要把多次获取的结果粘在一起，变成我们可以理解的信息，第二种情况，我们在另一端接收的时候，就必须进行拆包处理，因为每次接收的信息，可能是另一个远程端多次发送的包，被TCP粘在一起的。
- 粘包问题的解决策略：由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。
    - 1、消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
    - 2、在包尾增加回车换行符进行分割，例如FTP协议；
    - 3、将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
    - 4、更复杂的应用层协议。
- 采用的解决方案：
    - 目前我们微校使用的更复杂的应用层协议的包结构定义
    ```
    包头	包长度	包ID	版本号	Json数据	MD5	包尾
    WX+U/D/C)	69	1	1.0.0	{"action":"pay","total":1}	cc3d4f642efb68525ea4a7d21ff5ad7e	\r\n
    ```
    - 使用队列的方式，接收事件收到数据就往队列里添加，数据处理线程从队列里取数据，以分隔符 “\r\n” 就作为数据结尾，截取分隔符之前的数据 ，就得到了一个完整的数据段，然后再验证校验确保数据正确。







#### 关联项目
- SerialPort
  - 串口项目demo


























