#### 目录介绍
- 01.线程优化的背景
    - 1.1 实践背景说明
    - 1.2 遇到场景记录
    - 1.3 查找线程的来源
    - 1.4 查看项目的线程
    - 1.5 查找线程来源
- 02.线程现状和改造
    - 2.1 线程使用问题
    - 2.2 线程问题有哪些
    - 2.3 使用线程池管理线程
    - 2.4 常规解决方案
    - 2.5 线程改造方案
    - 2.6 线程改造的计划
- 03.线程的一些基础
    - 3.1 主线程与子线程
    - 3.2 UI线程的特点
    - 3.3 如何理解多线程
    - 3.4 线程交互Handler
- 04.异步任务的方式
    - 4.1 Thread直接创建
    - 4.2 Thread+Looper+handler
    - 4.3 AsyncTask
    - 4.4 HandlerThread
    - 4.5 IntentService
    - 4.6 线程池Executors
- 05.高效的使用线程
    - 5.1 多线程安全问题
    - 5.2 频繁发送消息问题
    - 5.3 轻量级线程池
    - 5.4 异步线程管理
    - 5.5 线程绑定生命周期
    - 5.6 排查线程CPU使用率飙升
- 06.优化线程的使用
    - 6.1 设置线程优先级方式
    - 6.2 避免Thread直接创建
- 07.线程卡顿是怎么回事
    - 7.1 线程如何卡顿
    - 7.2 如何模拟线程卡顿
    - 7.3 如何解决线程卡顿





### 01.线程优化的背景
#### 1.1 实践背景说明
- 说一下背景
    - 1.编译器自带的profiler工具显示项目在启动阶段有上百个线程被创建，这么多的线程真的都是由App创建的吗？
    - 2.过多的线程不仅仅带来了内存上的消耗同时也降低了cpu调度的效率，过多的cpu调度带来的消耗的坏处甚至超过了多线程带来的好处。
    - 3.每个设备能够创建的线程数是有限的，创建的线程数超限就会发生崩溃。为解决线程数超限带来的崩溃问题就需要降低线程的个数，既然需要降低线程的个数，那需要查找线程的来源。



#### 1.2 遇到场景记录
- 通常会遇到以下几个问题
    - 某个场景会创造过多的线程，最终导致线程OOM
    - 线程池过多问题，比如三方库有一套线程池，自己项目也有一套线程池，随着三方/二方业务接入，导致了不相兼容的线程池数越多，降低了全体线程池数的调度效率，比如多个okhttp的调用
    - 老代码原因导致，new Thread横行，又或者是各种线程使用不规范，导致工程混乱
    - 即使是空闲时候，依旧有线程在不断Waiting
    - 偶发各种线程死锁问题
- 导致的结果
    - 会遇到各种线程不明的情况，对排查问题或者解决问题带来极大的考验。



#### 1.3 查找线程的来源
- 如何查找线程的来源？
    - 新建一个空项目，创建完成后不添加任何代码直接运行项目，然后查看profiler中显示的线程，可以发现profiler中显示有10多个线程。
    - 通过线程名，大致可以推测出线程的创建者分别有安卓系统、profile自身、Android Studio等，除此之外还有主线程。
- 主要是哪些线程呢？
    - 一个空项目，至少包含主线程main、Binder线程，FinalizerDaemon线程、FinalizerWatchdog线程、RenderThread、ReferenceQueued、HeapTaskDaemon、SignalCatcher、GCDaemon等等。


#### 1.4 查看项目的线程
- 首先查看进程
    - 通过命令查看App存在的进程，主要是获取uid数据：adb shell ps | grep com.zuoyebang.iotunion
- 然后通过进程uid获取线程
    - 通过命令行初步查看uid对应进程的线程：adb shell ps -T | grep u0_a579
- 分析进程中创建的线程
    - 这些线程有系统的线程，系统的线程占了很大一部分。剩下就是业务自己创建的线程以及三方库创建的线程，接下来就是要查找出线程的来源。
    - 创建线程就需要调用线程的构造方法，所以可以hook线程的构造方法，然后获取堆栈，这样就能知道线程的来源。


#### 1.5 查找线程来源
- epic是一个可以hook的框架
    - 可以hook普通方法、构造方法、系统方法，但是存在兼容性问题，在一些设备上运行会崩溃，该框架已经很久没维护了。
- aspectj是基于AspectJ
    - 在此基础上扩展出来可应用于Android开发平台的AOP框架，可作用于java源码，class文件及jar包，同时支持kotlin的应用，但是在高版本的gradle上会出现编译问题。



### 02.线程使用的现状
#### 2.1 线程使用问题
- 线程数过多，本质上是直接创建线程，没有复用线程，每当来一个任务就创建一个线程，使得创建的线程越来越多。
- 项目中使用了过多的线程池，没有统一线程池，最好一个项目中只有一个线程池。



#### 2.2 线程问题有哪些
- UI 线程如果阻塞，会导致界面卡顿、ANR 等问题。
    - 为了保证 UI 的流畅性，一些耗时的工作就不能在主线程中进行处理了，例如，网络操作、I/O 操作等。绝大多数，耗时操作都应该在子线程中处理。


#### 2.3 使用线程池管理线程
- 因为在系统中创建线程是一个比较耗费资源的事, 所以不能频繁创建和释放线程, 因此在效率上考虑通常会使用线程池, 同时也便于线程的管理。
    - Android中的AsyncTask就使用了线程池。建议封装简单型的线程池库，主要是处理cpu，io，ui级相关的业务逻辑。


#### 2.4 常规解决方案
- 第一种：团队增加cr机制，review代码准入
    - 比如定制Thread的规范，又或者是定义项目统一的线程池，在项目中去使用。这个方案优点就是可操作性强，便于团队去实施。
- 第二种：
    - 通用的方案实践，比较流行的方案是通过字节码插桩的方式，统一做线程监控亦或进行线程统一，比如监控处理的matrix，还有优化相关的booster等。



#### 2.5 线程改造方案
- 方案1：使用统一的线程池
    - 不要手动创建线程，将项目中使用线程的地方替换成线程池，最好一个项目中只有一个线程池。
- 方案2：对于三方库创建的线程，如果三方库有替换线程的接口，则可以将三方库创建的线程替换成统一的线程池。
    - 如果三方库没有替换线程的接口，可以把三方库的源码下载下来，直接修改源码，然后将修改后的源码上传到公司的仓库。
- 方案3：使用字节码方案统一线程
    - 可以使用字节码插桩的方式将项目中的线程替换成统一的线程池，这个一下子搞不定，而且成本会比较高，需要经过严格的线下测试。



#### 2.6 线程改造的计划
- 前期计划         
    - 1、创建全局统一的线程池，将项目中使用线程的地方替换成线程池，如果三方库有替换线程的接口，则将三方库创建的线程替换成统一的线程池。
    - 2、最好进行灰度测试，通过服务端设置一个开关，开关默认开启，开关开了，则启用统一的线程池，否则使用老代码。
    - 3、由于三方库的线程并没有修改掉，项目中引入线程池，可能会导致线程数不降反升。
- 长期计划
    - 1、使用字节码插桩的方式将项目中的线程替换成统一的线程池，这个影响范围也比较大，需要经过严格的测试，滴滴开源的booster已经提供了这种功能。
- 长效机制
    - 1、为了防止后续在项目里面手动创建线程，可以在编译期间检测线程，如果手动创建线程，直接编译失败，缺点就是会导致编译时间变长。



### 03.线程的一些基础
#### 3.1 Android中的线程
- 主线程(有的也成UI线程)
    - 在Android当中, 当应用启动的时候，系统会给应用分配一个进程，顺便一提，大部分应用都是单进程的，不过也可以通过设置来使不同组件运行在不同的进程中。
    - 在创建进程的同时会创建一个线程，应用的大部分操作都会在这个线程中运行。所以称为主线程，同时所有的UI控件相关的操作也要求在这个线程中操作，所以也称为UI线程。
- 为何会有子线程
    - 因为所有的UI控件的操作都在UI线程中执行，如果在UI线程中执行耗时操作，例如网络请求等，就会阻塞UI线程，导致系统报ANR(Application Not Response)错误。
    - 因此对于耗时操作需要创建工作线程来执行而不能直接在UI线程中执行。这样就需要在应用中使用多线程，但是Android提供的UI工具包并不是线程安全的，也就是说不能直接在工作线程中访问UI控件，否则会导致不能预测的问题， 因此需要额外的机制来进行线程交互，主要是让其他线程可以访问UI线程。



#### 3.2 UI线程的特点
- Android UI线程（主线程）有几个特点：
    - 只能在 UI 线程操作 UI 视图，不能在子线程中操作。不能在 UI 线程中进行耗时操作，否则会阻塞 UI 线程，引起 ANR、卡顿等问题。
- 在 Android 开发中，我们通常将一些耗时的操作使用异步任务的方式进行处理。
    - 例如这样一种这种场景，子线程在后台执行一个异步任务，任务过程中，需要 UI 进程展示进度，这时我们就需要一个工具来实现这种需求。
    - Android 系统为开发人员提供了一个异步任务类（AsyncTask）来实现上面所说的功能，即它会在一个子线程中执行计算任务，同时通过主线程的消息循环来获得更新应用程序界面的机会。


#### 3.3 如何理解多线程
- 为什么会有多线程：
    - 因为并行执行多任务


#### 3.4 线程交互Handler
- 在Android当中, 工作线程主要通过Handler机制来访问UI线程。
    - 当然还有一些封装好的类例如AsyncTask可以使用, 但是本质仍是使用Handler。
- Handler机制主要由4部分组成, Looper, 消息队列, 消息类和Handler组成。
    - 其中Looper和消息队列是和线程绑定的, 每个线程只会有一个Looper和一个消息队列, 当Looper启动时，它会无限循环尝试从消息队列中获取消息实例，如果没有消息则会阻塞等待。
    - 当Handler发送消息时会把消息实例放入消息队列中，Looper从中取得消息实例然后就会调用Handler的相关方法，因为Looper是线程绑定的, 如果绑定的是UI线程，那么此时Handler的方法就会在UI线程中得到执行，线程间就是这样进行交互的。



### 04.异步任务的方式
#### 4.1 Thread直接创建
- 最直接的方式，就是使用 Java 提供的 Thread 类进行线程创建，从而实现异步。
- 遇到的问题有哪些？
    - 继承Thread，或者实现接口Runnable来开启一个子线程，无法准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。当线程出现异常的时候，如何避免导致崩溃问题？
= 开启Thread线程案例如下
    - **一般开启线程的操作如下所示**
        ``` 
        new Thread(new Runnable() {
            @Override
            public void run() {
                //做一些任务
            }
        }).start();
        ``` 
    - 分析
        - 创建了一个线程并执行，它在任务结束后GC会自动回收该线程。
        - 在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕。
- **主要的弊端有这些**
    - 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM
    - 使用start()方法启动线程，该线程会在run()方法结束后，自动回收该线程。虽然如此，在某些场景中线程业务的处理速度完全达不到我们的要求，系统中的线程会逐渐变大，进而消耗CPU资源，大量的线程抢占宝贵的内存资源，可能还会出现OOM，即便没有出现，大量的线程回收也会个GC带来很大的压力。
    - 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿
    - 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失



#### 4.2 Thread+Looper+handler
- Android 提供了 Handler 机制来进行线程之间的通信，我们可以使用 Android 最基础的异步方式：Thread + Looper + handler 来进行异步任务。
- 优点：
    - 操作简单，无学习成本。
- 缺点：
    - 代码规范性较差，不易维护。每次操作都会开启一个匿名线程，系统开销较大。
    - 多任务同时执行时不易精确控制线程。
- 使用范围：
    - 多个异步任务的更新UI



#### 4.3 AsyncTask
- 较为轻量级的异步类
    - 封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于后台与界面持续交互。便于执行后台任务以及在子线程中进行UI操作。
- 优点：
    - 结构清晰，使用简单，适合后台任务的交互。
    - 异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。
- 缺点：
    - 结构略复杂，代码较多。每个 AsyncTask 只能被执行一次，多次调用会发生异常。
    - AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。
- 使用范围
    - 单个异步任务的处理



#### 4.4 HandlerThread
- HandlerThread 是一个自带 Looper 消息循环的线程类。
    - 处理异步任务的方式和 Thread + Looper + Handler 方式相同。
- 优点：
    - 简单，内部实现了普通线程的 Looper 消息循环。可以串行执行多个任务。
    - 内部拥有自己的消息队列，不会阻塞 UI 线程。
- 缺点：
    - 没有结果返回接口，需要自行处理。消息过多时，容易造成阻塞。
    - 只有一个线程处理，效率较低。线程优先级默认优先级为 THREAD_PRIORITY_DEFAULT，容易和 UI 线程抢占资源。



#### 4.5 IntentService
- IntentService 继承自 Service 类。
    - 用于启动一个异步服务任务，它的内部是通过 HandlerThread 来实现异步处理任务的。是一种异步、会自动停止的服务。
- 优点：
    - 只需要继承 IntentService，就可以在 onHandlerIntent 方法中异步处理 Intent 类型任务了。
    - 任务结束后 IntentService 会自行停止，无需手动调用 stopService。
    - 可以执行处理多个 Intent 请求，顺序执行多任务。
    - IntentService 是继承自 Service，具有后台 Service 的优先级。
- 缺点：
    - 需要启动服务来执行异步任务，不适合简单任务处理。
    - 异步任务是由 HandlerThread 实现的，只能单线程、顺序处理任务。
    - 没有返回 UI 线程的接口。


### 4.6 线程池Executors
- 利用 Executors 的静态方法创建多线程
    - java当中主要使用Thread和Executor来实现多线程. Thread用于直接创建线程, 在Android中也可以直接使用这个类, Looper中就包含一个Thread实例. Executor是一个接口, 大部分java中自带的实现都使用了线程池来管理多线程。
    - newCachedThreadPool()、newFixedThreadPool()、newSingleThreadExecutor() 及重载形式实例化 ExecutorService 接口即得到线程池对象。
- 优点：
    - 线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。
    - 适合执行大量异步任务，提高性能。
    - 灵活性高，可以自由控制线程数量。
    - 扩展性好，可以根据实际需要进行扩展。
- 缺点：
    - 代码略显复杂。线程池本身对系统资源有一定消耗。
    - 当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。
    - 每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。
    - 线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。



### 05.高效的使用线程
#### 5.1 多线程安全问题
- 线程安全问题
    - 使用多线程时需要注意的是线程安全的问题, 因为同一进程中的线程可以共享内存, 虽然这种方式效率很高, 但是会导致线程干扰和内存一致性的问题。[博客](https://github.com/yangchong211/YCBlogs)
- 锁机制
    - 解决这些问题的主要方法是使用Synchronized关键字来加锁. 基本原理就是线程要对对象进行操作前需要先获取锁, 如果一个线程正在操作某个对象, 那么它就会持有相应的锁, 后来的线程想要操作这个对象, 只能等待前面的线程释放锁之后才有机会获取锁并进行操作.


#### 5.2 频繁发送消息问题
- 频繁发送消息，处理消息不靠谱的，引起不靠谱的原因有如下
    - 发送的消息太多，Looper负载越高，任务越容易积压，进而导致卡顿
    - 消息队列有一些消息处理非常耗时，导致后面的消息延时处理
    - 大于Handler Looper的周期时基本可靠（例如主线程>50ms）
    - 对于时间精确度要求较高，不要用handler的delay作为即时的依据
- 如何优化保证可靠性
    - 消息精简，从数量上处理
    - 队列优化，重复消息过滤
    - 互斥消息取消
    - 复用消息
- 消息空闲IdleHandler
    ``` java
    MessageQueue.IdleHandler ideHandler =new MessageQueue.IdleHandler() {
            @Override
            public boolean queueIdle() {
                return false;
            }
        };
    Looper.myQueue().addIdleHandler(ideHandler);
    ```
- 使用独享的Looper(HandlerThread)
    ``` java
    HandlerThread handlerThread = new HandlerThread("A-Thread");
    handlerThread.start();
    Handler handler = new Handler(handlerThread.getLooper());
    ```


#### 5.6 排查线程CPU使用率飙升
- 首先模拟一个CPU高使用率场景
    ``` java
    public class HighCpuTest {
        public static void main(String[] args) {
            List<HignCpu> cpus = new ArrayList<>();
            Thread highCpuThread = new Thread(()->{
                int i = 0;
                while (true){
                    HignCpu cpu = new HignCpu("Java日知录",i);
    
                    cpus.add(cpu);
                    System.out.println("high cpu size:" + cpus.size());
                    i ++;
                }
            });
            highCpuThread.setName("HignCpu");
            highCpuThread.start();
        }
    }
    ```
- 在main方法中开启了一个线程，无限构建HighCpu对象。
    ``` java
    @Data
    @AllArgsConstructor
    public class HignCpu {
        private String name;
        private int age;
    }
    ```
- 排查步骤
    - 第一步，使用 top 找到占用 CPU 最高的 Java 进程。这一步监控cpu运行状，显示进程运行信息列表。
    - 第二步，用 top -Hp 命令查看占用 CPU 最高的线程。
        - 那一个进程中有那么多线程，不可能所有线程都一直占着 CPU 不放，这一步要做的就是揪出这个罪魁祸首，当然有可能不止一个。执行top -Hp pid命令，pid 就是前面的 Java 进程。然后再查查到占用CPU最高的那个线程PID。
    - 第三步，查看堆栈信息，定位对应代码。
        - 通过printf命令将其转化成16进制，之所以需要转化为16进制，是因为堆栈里，线程id是用16进制表示的。得到线程id后然后通过jstack命令查看堆栈信息。
        - 找到了耗CPU高的线程对应的线程名称“HighCpu”，以及看到了该线程正在执行代码的堆栈。最后，根据堆栈里的信息，定位到对应死循环代码，搞定。





### 06.优化线程的使用
#### 6.1 设置线程优先级方式
- 在 Android 中，有两种常见的设置线程优先级的方式：
    - 第一种，使用 Thread 类实例的 setPriority 方法，来设置线程优先级。
    - 第二种，使用 Process 类的 setThreadPriority 方法，来设置线程优先级。
- 这两种设置线程的优先级，一种是 Java 原生版本，另一种是 Android API 版本。
    - 这两种方式是不同的，Android 更推荐使用第二种方式。
- https://blog.csdn.net/u011578734/article/details/110549238




#### 6.2 避免Thread直接创建




### 07.线程卡顿是怎么回事
#### 7.1 线程如何卡顿


#### 7.2 如何模拟线程卡顿


#### 7.3 如何解决线程卡顿






- 思考一些问题
    - 了解了如何创建线程，来执行异步任务，那么如果大量的使用线程，会不会影响 UI 线程呢？会不会产生卡顿呢?答案是肯定的。
    - 因为用户手机的 CPU 资源是有限的，内存也是有限的，如果无节制的同一时刻创建的大量的线程，就会导致线程和 UI 线程同时抢占 CPU 资源，造成 UI 线程执行变慢，产生卡顿等问题；
    - 并且线程创建是有代价的，线程不但占用了大量的 CPU 资源，同时也占用了大量的内存资源，Android 在真正创建线程时，会为每个线程申请 1040KB 的内存资源，大量的线程就有可能导致 OOM 等问题。
    - 另外，线程的创建和销毁也会占用系统资源来执行，所以应该合理的使用线程。
- 如何高效的使用线程
    - 将异步任务分类，根据任务的紧急程度，使用不同优先级的线程来执行。
    - 将紧急任务，交给优先级高的线程来执行，并且要注意，线程不能产生长时间阻塞，否则会影响后续任务的执行。
    - 将不紧急任务，交给低优先级线程来执行，并且控制线程数量，少量线程，慢慢执行即可。例如，可以创建一个类似于 AnsyncTask 的全局的单线程任务队列，使用 1 个线程来执行一些不紧急的任务。
    - 使用线程池来优化线程的创建和管理线程。我们可以使用线程池来全局的管理线程的创建和执行，以此来避免频繁的线程创建和销毁，提高系统的性能。
    - 不要使用默认的线程优先级。通常，新创建的线程的线程优先级，默认情况下继承了父线程的线程优先级的，例如，在 UI 线程中创建了一个子线程，那么子线程的线程优先级就和 UI 线程是相同的。
    - 尽可能的将线程优先级级别设置的低一些，以避免子线程和 UI 线程竞争 CPU 资源。
    - 设置线程优先级时，应注意线程优先级的设置方法。



### 参考博客
- 线程监控 - 死锁、存活周期与 CPU 占用率
    - https://www.jianshu.com/p/a4efccd09e02
- Android性能优化-线程监控与线程统一
    - https://juejin.cn/post/7143944351016550437










