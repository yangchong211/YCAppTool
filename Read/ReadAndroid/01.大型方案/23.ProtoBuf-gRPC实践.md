#### 目录介绍
- 01.gRPC学习背景
    - 1.1 为什么要学RPC
    - 1.2 RPC是什么
    - 1.3 网络库收益分析
    - 1.4 学习计划说明
- 02.ProtoBuf的介绍
    - 2.1 ProtoBuf是什么
    - 2.2 ProtoBuf和json
    - 2.3 ProtoBuf问题思考
    - 2.4 ProtoBuf特点
    - 2.5 ProtoBuf存储格式
    - 2.6 ProtoBuf优缺点
    - 2.7 创建proto文件
    - 2.8 ProtoBuf核心思想
    - 2.9 ProtoBuf总结
- 03.gRPC实践的介绍
    - 3.1 gRPC简单介绍
    - 3.2 为何要用gRPC
    - 3.3 gRPC定义服务
    - 3.4 gRPC生成代码
    - 3.5 gRPC如何使用
    - 3.6 同步和异步操作
    - 3.7 gRPC一些操作
    - 3.9 gRPC问题解决
    - 3.10 理解gRPC协议
- 04.gRPC通信实践
    - 4.1 gRPC通信技术点
    - 4.2 核心设计思路
    - 4.3 定义ProtoBuf消息
    - 4.4 请求/响应的读写
    - 4.5 网络日志打印
    - 4.6 如何做网络缓存
- 05.ProtoBuf核心原理
    - 5.1 ProtoBuf数据结构
    - 5.2 ProtoBuf编码方式
    - 5.3 
- 06.gRPC核心原理
    - 6.1 channel通道创建
    - 6.2 channel通道复用
    - 





### 01.gRPC学习背景
#### 1.1 为什么要学gRPC
- 在Android开发中，使用gRPC可以带来以下好处：
    - 高效性：gRPC使用ProtoBuf作为默认的序列化协议，比JSON和XML等其他序列化协议更高效，可以减少网络带宽和CPU使用率。
    - 可靠性：gRPC使用HTTP/2协议作为底层传输协议，可以提供更可靠的连接和流控制，同时支持TLS加密和认证。
    - 易于使用：gRPC提供了自动生成代码的工具，可以方便地生成客户端和服务器端的代码，同时提供了丰富的文档和示例。
    - 可扩展性：gRPC支持多种类型的RPC，包括简单RPC、流式RPC和双向流式RPC，可以满足不同的应用场景和需求。



#### 1.2 RPC是什么
- rpc概述
    - RPC（Remote Procedure Call）-远程过程调用，他是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
    - RPC 协议包括序列化、协议编解码器和网络传输栈。
- gRPC介绍
    - gRPC 一开始由 Google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。
- rpc和http区别
    - RPC 和 HTTP都是微服务间通信较为常用的方案之一，其实RPC 和 HTTP 并不完全是同一个层次的概念，它们之间还是有所区别的。
    - 1.RPC 是远程过程调用，其调用协议通常包括序列化协议和传输协议。序列化协议有基于纯文本的 XML 和 JSON、有的二进制编码的ProtoBuf。传输协议是指其底层网络传输所使用的协议，比如 TCP、HTTP。
    - 2.可以看出HTTP是RPC的传输协议的一个可选方案，比如说 gRPC 的网络传输协议就是 HTTP。HTTP 既可以和 RPC 一样作为服务间通信的解决方案，也可以作为 RPC 中通信层的传输协议（此时与之对比的是 TCP 协议）。




#### 1.3 网络库收益分析
- 使用gRPC作为网络方案可以带来以下收益：
    - 使用gRPC作为网络方案可以带来高效性、跨平台和语言、可靠性、易于使用和可扩展性等收益。
    - 同时可以减少手动编写代码的工作量，提高开发效率。




#### 1.4 学习计划说明
- 基础入门掌握
    - 1.完成ProtoBuf基础了解和学习【3h】【完成】
    - 2.尝试ProtoBuf和json效率测试【3h】【完成】
    - 3.gRPC环境配置和官方文档和Demo学习【6h】【完成】
    - 4.熟练使用gRPC，比如将玩Android接口，用gRPC方式去请求【8h】【进行中】
    - 5.gRPC的四种通信模式【4h】【未开始】
- 原理解读说明
    - 1.理解gRPC的基础通信原理【4h】【进行中】
    - 2.gRpc网络请求的核心设计思路【4h】【未开始】
    - 3.Proto文件如何在编译期间生成java文件原理研究【4h】【未开始】
    - 4.Proto有哪些缺点，如何优化，跟json，xml空间上性能分析【4h】【未开始】
- 技术精进计划
    - 1.理解各种网络请求库的设计，性能对比，各自偏向解决问题【4h】【未开始】
    - 2.通透理解protoBuf实现数据缓冲的原理，谷歌如何做性能优化的反思【4h】【未开始】
    - 3.讲出来，实践写Demo，内化。和同事讨论关键技术点【2h】【未开始】



### 02.ProtoBuf的介绍
#### 2.1 ProtoBuf是什么
- ProtoBuf简单介绍
    - 它是Google公司发布的一套开源编码规则，基于二进制流的序列化传输，可以转换成多种编程语言，几乎涵盖了市面上所有的主流编程语言，是目前公认的非常高效的序列化技术。
- ProtoBuf是一种灵活高效可序列化的数据协议
    - 相于XML，具有更快、更简单、更轻量级等特性。支持多种语言，只需定义好数据结构，利用ProtoBuf框架生成源代码，就可很轻松地实现数据结构的序列化和反序列化。
    - 一旦需求有变，可以更新数据结构，而不会影响已部署程序。
- ProtoBuf的Github主页：
    - 官方开源地址 ：https://github.com/protocolbuffers/protobuf
    - 语法指南：https://developers.google.com/protocol-buffers/docs/proto



#### 2.2 ProtoBuf和json
- ProtoBuf就好比信息传输的媒介
    - 如果用一句话来概括ProtoBuf和JSON的区别的话，那就是：对于较多信息存储的大文件而言，ProtoBuf的写入和解析效率明显高很多，而JSON格式的可读性明显要好。
- 如何对json和ProtoBuf进行效率测试
    - 核心思路：创建同样数据内容的对象。然后将对象序列化成字节数组，获取字节数据大小，最后又将字节反序列化成对象。
    - 效率对比：主要是比较序列化耗时，序列化之后的数据大小，以及反序列化的耗时。注意：必须保证创建数据内容是一样的。
- 测试案例分析如下
    ```
    2023-05-09 09:31:49.699 23442-23442/com.yc.appgrpc E/Test效率测试：: Gson 序列化耗时：14
    2023-05-09 09:31:49.699 23442-23442/com.yc.appgrpc E/Test效率测试：: Gson 序列化数据大小：188
    2023-05-09 09:31:49.701 23442-23442/com.yc.appgrpc E/Test效率测试：: Gson 反序列化耗时：2
    2023-05-09 09:31:49.701 23442-23442/com.yc.appgrpc E/Test效率测试：: Gson 数据：{"persons":[{"id":1,"name":"张三","phones":[{"number":"110","type":"HOME"}]},{"id":2,"name":"李四","phones":[{"number":"130","type":"MOBILE"}]},{"id":3,"name":"王五","phones":[{}]}]}
    2023-05-09 09:31:49.720 23442-23442/com.yc.appgrpc E/Test效率测试：: protobuf 序列化耗时：4
    2023-05-09 09:31:49.720 23442-23442/com.yc.appgrpc E/Test效率测试：: protobuf 序列化数据大小：59
    2023-05-09 09:31:49.722 23442-23442/com.yc.appgrpc E/Test效率测试：: protobuf 反序列化耗时：2
    2023-05-09 09:31:49.725 23442-23442/com.yc.appgrpc E/Test效率测试：: protobuf 数据：# com.yc.appgrpc.AddressBookProto$AddressBook@83d0213a
        people {
          id: 1
          name: "\345\274\240\344\270\211"
          phones {
            number: "110"
            type: HOME
            type_value: 1
          }
        }
        people {
          id: 2
          name: "\346\235\216\345\233\233"
          phones {
            number: "120"
          }
        }
        people {
          id: 3
          name: "\347\216\213\344\272\224"
          phones {
            number: "130"
          }
        }
    ```
- 测试结果说明
    - 空间效率：Json:188个字节；ProtoBuf:59个字节
    - 时间效率：Json序列化:14ms，反序列化:2ms；ProtoBuf序列化:4ms 反序列化:2ms
- 可以得出结论
    - 通过以上的时间效率和空间效率，可以看出protoBuf的空间效率是JSON的2-5倍，时间效率要高，对于数据大小敏感，传输效率高的模块可以采用protoBuf库。



#### 2.3 ProtoBuf问题思考
- ProtoBuf 是一个小型的软件框架，也可以称为protocol buffer 语言，带着疑问会发现Proto 有很多需要了解：
    - Proto 文件书写格式，关键字package、option、Message、enum 等含义和注意点是什么？
    - 消息等嵌套如何使用？实现的原理？
    - Proto 文件对于不同语言的编译，和产生的obj 文件的位置？
    - Proto 编译后的cc 和java 文件中不同函数的意义？
    - 如何实现*.proto 到*.java、*.h、*.cc 等文件？
    - 数据包的组成方式、repeated 的含义和实现？
    - Proto 在service和client 的使用，在java 端和native 端如何使用？
    - 与xml 、json 等相比时间、空间上的比较如何？



#### 2.4 ProtoBuf特点
- 先看看Proto文件的一个案例
    ```
    message SearchRequest {
      string query = 1;
      int32 page_number = 2;
      int32 result_per_page = 3;
    }
    ```
- 序列化数据为何说数据小
    - 序列化数据时，不序列化key的name，使用key的编号替代，减小数据。
    - 如上面的数据在序列化时query ，page_number以及result_per_page的key不会参与，由编号1,2,3替代。
    - 这样在反序列的时候可以直接通过编号找到对应的key，这样做确实可以减小传输数据，但是编号一旦确定就不可更改；
- 没有赋值的key，不参与序列化：
    - 序列化时只会对赋值的key进行序列化，没有赋值的不参与，在反序列化的时候直接给默认值即可；
- 可变长度编码：
    - 主要缩减整数占用字节实现，例如java中int占用4个字节，但是大多数情况下，我们使用的数字都比较小，使用1个字节就够了，这就是可变长度编码完成的事；
- TLV：
    - TLV全称为Tag_Length_Value，其中Tag表示后面数据的类型，Length不一定有，根据Tag的值确定，Value就是数据了，TLV表示数据时，减少分隔符的使用，更加紧凑；



#### 2.5 ProtoBuf存储格式
- 如何理解TLV结构：TLV全称为Tag_Length_Value
    - Tag块并不是只表示数据类型，其中数据编号也在Tag块中，Tag的生成规则如下：Tag块的后3位表示数据类型，其他位表示数据编号。Tag中1-15编号只占用1个字节，所以确保编号中1-15为常用的，减少数据大小。
    - Length不一定有，依据Tag确定，例如数值类型的数据，使用VarInts不需要长度，就只有Tag-Value，string类型的数据就必须是Tag-Length-Value
    - Value:消息字段经过编码后的值
    - ![image](https://img-blog.csdnimg.cn/515c8ab9fa024acfa2cfd928b662b538.png)



#### 2.6 ProtoBuf优缺点
- ProtoBuf优点
    - 性能：1.体积小，序列化后，数据大小可缩小3-10倍；2.序列化速度快，比XML和JSON快20-100倍；3.传输速度快，因为体积小，传输起来带宽和速度会有优化
    - 使用优点：1.使用简单，proto编译器自动进行序列化和反序列化；2.维护成本低，多平台仅需维护一套对象协议文件(.proto)；3.向后兼容性(扩展性)好，不必破坏旧数据格式就可以直接对数据结构进行更新；4.加密性好，Http传输内容抓包只能看到字节
    - 使用范围：跨平台、跨语言(支持Java, Python, Objective-C, C+, Dart, Go, Ruby, and C#等），可扩展性好
- ProtoBuf缺点
    - 功能缺点：不适合用于对基于文本的标记文档（如HTML）建模，因为文本不适合描述数据结构
    - 通用性较差：json、xml已成为多种行业标准的编写工具，而ProtoBuf只是Google公司内部的工具
    - 自解耦性差：以二进制数据流方式存储（不可读），需要通过.proto文件才能了解到数据结构
    - 阅读性差：.proto文件去生成相应的模型，而生成出来的模型无论从可读性还是易用性上来说都是较差的。并且生成出来的模型文件是不允许修改的（protoBuf官方建议），如果有新增字段，都必须依赖于.proto文件重新进行生成。
- .protoBuf会导致客户端的体积增加许多
    - protoBuf所生成的模型文件十分巨大，略复杂一些的数据可以达到1MB，请注意，1MB只是一个模型文件。
    - 导致该问题的原因是，protoBuf为了实现对传输数据的信息补全（可以参看编码原理），将编码、解码的代码都整合到了每一个独立的模型文件中，因此导致代码有非常大的冗余




#### 2.7 创建proto文件
- proto文件基础介绍
    ``` protobuf
    syntax = "proto3";
    option java_multiple_files = true;
    option java_package = "com.yc.appgrpc";
    option java_outer_classname = "HelloWorldProto";
    option objc_class_prefix = "HLW";
    package helloworld;
    
    service Greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }
    
    message HelloRequest {
      string name = 1;
    }
    message HelloReply {
      string message = 1;
    }
    ```
- 版本声明：syntax = "proto3";
    - .proto文件中非注释非空的第一行必须使用Proto版本声明，如果不使用proto3版本声明，Protobuf编译器默认使用proto2版本。
- 指定包名：package
    - .proto文件中可以新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。包的声明符会根据使用语言的不同影响生成的代码
- 导入外部包：import
    - 通过import声明符可以引用其他.proto里的结构数据体
- 消息定义：message
    - ProtoBuf中，消息即结构化数据。其中变量的声明结构为：字段规则 + 字段类型 + 字段名称 + 【=】 + 标识符 + 【默认值】
    - 字段规则有：optional: 结构体可以包含该字段零次或一次（不超过一次）；repeated: 该字段可以在格式良好的消息中重复任意多次（包括0），其中重复值的顺序会被保留，相当于数组
- 定义服务：service
    - 如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，ProtoBuf编译器将会根据所选择的不同语言生成服务接口代码及stub。
- 关于ProtoBuf更多内容
    - ProtoBuf全面解析：https://www.jianshu.com/p/f6115e2240d2



#### 2.8 ProtoBuf核心思想
- 第一步：开发者首先需要编写.proto文件
    - 按照proto格式编写文件，指定消息结构。
- 第二步：编译.proto文件生成对应的代码
    - 需要把.proto文件丢给目标语言的protoBuf编译器。protoBuf编译器将生成相应语言的代码。
    - 例如，对Java来说，编译器生成相应的.java文件，以及一个特殊的Builder类（该类用于创建消息类接口）。
- 第三步：使用代码传输数据，调用api
    - protoBuf编译器会生成相应的方法，这些方法包括序列化方法和反序列化方法。
    - 序列化方法用于创建和操作object，将它们转换为序列化格式，以进行存储或传输。调用toByteArray()方法将object转为byte字节数组。
    - 反序列化方法用于将输入的protoBuf数据转换为object。调用parseFrom(bytes)方法将bytes字节数据转为object对象。
    - 编译器完成它的工作后，开发人员所要做的，就是在发送/接收数据的代码中使用这些方法。



#### 2.9 ProtoBuf总结
- Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。
    - 所以 pb 体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。
    - Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！
    - Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。
- Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。
    - 简化了多语言交互的复杂度，使得编码解码工作有了生产力。
    - Protocol Buffer 不是自我描述的，离开了数据描述 .proto 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。




### 03.gRPC实践的介绍
#### 3.1 gRPC简单介绍
- gRPC的简单介绍
    - gRPC是一个高性能、开源和通用的RPC框架，面向移动和HTTP/2设计。目前提供C、Java和Go语言版本，分别是grpc、grpc-java、grpc-go。
    - gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。
    - gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统。
- gRPC(Java)的Github主页：
    - https://github.com/grpc/grpc-java



#### 3.2 为何要用gRPC
- 为什么要使用ProtoBuf和gRPC
    - 简而言之，ProtoBuf就好比信息传输的媒介，类似我们常用的json，而grpc则是传输他们的通道，类似我们常用的socket。
- gRPC被谷歌推荐
    - 作为google公司极力推荐的分布式网络架构，基于HTTP2.0标准设计，使用用ProtoBuf作为序列化工具，在移动设备上表现更好，更省电和节省空间占用。
- 像这种国外的开源框架，还是建议大家先直接阅读官方文档，再看国内的文章，这样才不容易被误导。
    - [官方文档](https://grpc.io/docs/platforms/android/java/quickstart/)
    - [官方示例](https://github.com/grpc/grpc-java/tree/master/examples/android)
    - 具体如何实践可以看：[手把手教你使用ProtoBuf](https://blog.csdn.net/xuexiangjys/article/details/88780124)
    - [Android中使用GRPC简明教程](https://blog.csdn.net/haohulala/article/details/129211997)



#### 3.3 gRPC定义服务
- gRPC的四种通信模式
    - gRPC针对不同的业务场景，一共提供了四种通信模式，分别是简单一元模式，客户端流模式，服务端流模式和双向流模式，接下来这个进行介绍。
    - Unary-从客户机发送单个请求，从服务器发送回单个响应。
    - Server Streaming-从客户机发送一个请求，然后从服务器发送回一系列消息。
    - Client Streaming -从客户端向服务器发送一系列消息，服务器用一条消息作出回应。
    - Bidirectional streaming -客户端和服务器相互发送消息流的地方。
    ```
    service Greeter {
      // 简单一元模式
      rpc simpleHello (Request) returns (Reply) {}
      // 客户端流模式
      rpc clientStream (stream Request) returns (Reply) {}
      // 服务端流模式
      rpc serverStream (Request) returns (stream Reply) {}
      // 双向流模式
      rpc bothFlowStream (stream Request) returns (stream Reply) {}
    }
    ```
- 简单一元模式
    - 所谓简单一元模式，实际上就是客户端和服务端进行一问一答的通信。
    - 这种通信模式是最简单的，应用场景有无线设备之间和客户端之间保持连接的心跳检测，每隔一段时间就给服务端发送一个心跳检测包，服务端接收到心跳包后就知道相应客户端处于连接状态。
- 客户端流模式
    - 客户端流模式的意思就是客户端可以一次性发送多个数据片段，当然数据片段是一个类，具体的类有哪些字段都是你在最开始的proto文件中进行指定的。
    - 这种模式的应用场景就比如客户端向服务端发送一连串的数据，然后服务端最后发送一个响应数据表示接收成功。
- 服务端流模式
    - 服务端流模式和客户端流模式正好相反，本质都是差不多的，应用场景有客户端发送一个数据包告诉服务端，我需要某某数据，然后服务器将对应的所有信息都发送给客户端。
- 双向流模式
    - 双向流模式是最后一种，也是最常用的一种，在这种模式中，客户端和服务端的通信没有什么限制，是比较理想的通信模式，应用场景也最为广泛，因为在这种模式中，你也可以只发送一个数据包。



#### 3.4 gRPC生成代码
- 从我们的 .proto 服务定义中生成 gRPC 客户端接口。
    - 使用proto带有特殊 gRPC Java 插件的协议缓冲区编译器来执行此操作。你需要使用 proto3编译器（支持 proto2 和 proto3 语法）以生成 gRPC 服务。
    ```
    service Greeter {
      rpc SayHello (HelloRequest) returns (HelloReply) {}
    }
    
    message HelloRequest {
      string name = 1;
    }
    message HelloReply {
      string message = 1;
    }
    ```
- 编译器生成的代码如下所示
    - Greeter 会编译生成 GreeterGrpc.java，具有服务中定义的所有方法Greeter。
    - HelloRequest 会编译生成 HelloRequest.java，HelloRequestOrBuilder.java。
    - HelloReply 会编译生成 HelloReply.java ，HelloReplyOrBuilder.java。
    - 以message开头的对象，编译会生成协议缓冲区代码的代码，用于填充、序列化和检索我们的请求和响应消息类型。





#### 3.5 gRPC如何使用
- 大概的实践步骤如下所示
    - 第一步：添加项目中build中的插件配置。添加：classpath "com.google.protobuf:protobuf-gradle-plugin:0.9.1"
    - 第二步：在App模块下添加plugin插件配置，添加基础库依赖等操作。还要做一些proto配置。具体看app模块下的build.gradle文件。
    - 第三步：在main目录下创建proto目录，创建一个和java目录同级的proto文件夹，这样做是因为在build.gradle文件中指定了去proto文件夹中找到*.proto文件，并且编译成java代码。
    - 第四步：编译项目，在build目录(build->generated->source->proto->debug)下看到对应的java文件
    - 第五步：开始使用gRPC去做网络请求操作。具体可以看：HelloWorldActivity
- 问题思考一下
    - 能否把生成的代码拷贝出来（如果proto不经常变的情况），把插件禁用掉，避免每次都生成？？？
- 如何使用gRPC去做网络请求
    ```
    //构建Channel
    channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();
    //构建服务请求API代理
    GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(channel);
    //构建请求实体，HelloRequest是自动生成的实体类
    HelloRequest request = HelloRequest.newBuilder().setName(message).build();
    //进行请求并且得到响应数据
    HelloReply reply = stub.sayHello(request);
    //得到请求响应的数据
    String replyMessage = reply.getMessage();
    ```



#### 3.6 同步和异步操作
- 创建一个存根，或者更确切地说，两个存根：
    - 阻塞/同步存根：这意味着 RPC 调用等待服务器响应，并将返回响应或引发异常。
    - 一个非阻塞/异步存根，它对服务器进行非阻塞调用，异步返回响应。您只能使用异步存根进行某些类型的流式调用。
- 创建同步和异步操作如下
    ```
    //同步阻塞
    GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(channel);
    //异步调用
    GreeterGrpc.GreeterStub stub = GreeterGrpc.newStub(channel);
    ```


#### 3.7 gRPC一些操作
- RPC 超时
    - gRPC 允许客户指定他们愿意等待 RPC 完成多长时间，然后再以错误终止 RPC。在server端，可以查询特定 RPC 是否已过时，或者需要多少时间才能完成 RPC。
- RPC 终止
    - 在 gRPC 中，客户端和服务器都对调用的成功做出独立和本地的判断，它们的结论可能不一致。 
    - 这意味着，例如，您可能有一个 RPC 在服务器端成功完成（“我已经发送了我所有的响应！”）但在客户端失败（“响应到达前我已经截至了！”）。
- RPC 取消
    - 客户端或服务器可以随时取消 RPC。RPC会立即响应取消操作而终止，以便不再进行进一步的工作。



#### 3.9 gRPC问题解决
- io.grpc.StatusRuntimeException:　UNIMPLEMENTED
    - 这个错误网上很多，大部分情况下 是由于方法找不到，即客户端与服务端proto的内容或者版本不一致，这里只需要改成一致，一般问题都能解决
- DEADLINE_EXCEEDED: deadline exceeded after 149944644ns
    - 这种错误明细我这里就不打印了，这里一般是读取数据超时，
    - 问题原因：一般是grpc超时时间设置短了，或者下游服务响应超时。
    - 解决方案：修改grpc超时时间，或者检查grpc服务端是否有问题
- Exception: NAVAILABLE: upstream request timeout
    - 问题原因：这里可以理解为连接超时，这里说明健康检查也超时
    - 解决方案：检查grpc服务端是否有问题。
- INTERNAL: Received unexpected EOS on DATA frame from server
    - 问题原因：这里可翻译为收到了空消息，这里可能是服务端没响应
    - 解决方案：检查端口是否对应上，服务是否正常，特别是docker中的端口映射配置是否正确。
- io.grpc.StatusRuntimeException: UNKNOWN
    - 问题原因： 从字面意思是未知错误，这个是服务端反馈，主要是服务端报了一些未知异常，比如说参数传的有问题等
    - 解决方案： 检查客户端传参是否有个别异常，打印出有问题参数



#### 3.10 理解gRPC协议
- gRPC基于HTTP/2/协议进行通信，使用ProtoBuf组织二进制数据流，gRPC的协议格式如下图：
    - ![image](https://img-blog.csdnimg.cn/22a109e2d9f141f8806f21c3d6fa05b8.png)
- gRPC协议在HTTP协议的基础上，对HTTP/2的帧的有效包体(Frame Payload)做了进一步编码：gRPC包头(5字节)+gRPC变长包头，其中：
    - 5字节的gRPC包头由：1字节的压缩标志(compress flag)和4字节的gRPC包头长度组成；
    - gRPC包体长度是变长的，其是这样的一串二进制流：使用指定序列化方式(通常是ProtoBuf)序列化成字节流，再使用指定的压缩算法对序列化的字节流压缩而成的。如果对序列化字节流进行了压缩，gRPC包头的压缩标志为1。



### 05.ProtoBuf核心原理
#### 5.1 ProtoBuf数据结构



#### 5.2 ProtoBuf编码方式



### 06.gRPC核心原理
#### 6.1 channel通道创建



#### 6.2 channel通道复用
- 为何通道设置成复用
    - 对于客户端来说建立一个channel是昂贵的，因为创建channel需要连接。但是建立一个stub是很简单的，就像创建一个普通对象，因此Channel就需要复用。






### 案例
- Android使用GRPC进行通信过程解析
  - https://www.jb51.net/article/276659.htm
- GRPC 性能最佳做法
  - https://learn.microsoft.com/zh-cn/aspnet/core/grpc/performance?view=aspnetcore-7.0



#### 参考博客
- Android protoBuf 原理
    - https://blog.csdn.net/shift_wwx/article/details/120532407
- Protobuf编码原理和核心API
    - https://zhuanlan.zhihu.com/p/542208233
- 快速理解Protobuf的背景、原理、使用、优缺点
    - https://developer.aliyun.com/article/1081532
- 原生protobuf的缺陷，以及类库优化思路
    - https://www.jianshu.com/p/60d8480083f0
- grpc原理及四种实现方式
    - https://zhuanlan.zhihu.com/p/576031935
- Protobuf 使用介绍及原理
    - https://gitee.com/chenjim/ProtoBuf




- 参考
  - https://km.woa.com/articles/show/568259?kmref=search&from_page=1&no=1


