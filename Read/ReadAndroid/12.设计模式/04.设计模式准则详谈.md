#### 目录介绍
- 01.面向对象六大原则
- 02.单一职责原则介绍
- 03.开放封闭原则介绍
- 04.里式替换原则介绍
- 05.依赖倒置原则介绍
- 06.接口分离原则介绍
- 07.迪米特法则的介绍



### 01.面向对象六大原则
- 单一职责原则：指一个类的功能要单一，不能包罗万象。
- 开放封闭原则：指一个模块在扩展性方面应是开放的，在更改性方面应是封闭的。
- 替换原则：子类应当可以替换父类，并出现在父类能够出现的任何位置。
- 依赖原则：具体依赖抽象，上层依赖下层。
- 接口分离原则：模块间要通过抽象接口隔开，而不是通过具体的类强行耦合起来。
- 迪米特法则：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。



### 02.单一职责原则介绍
#### 2.1 先思考几个问题
- 01.如何理解类的单一指责，单一指责中这个单一是如何评判的？
- 02.懂了，但是会用么，或者实际开发中有哪些运用，能否举例说明单一职责优势？
- 03.单一指责是否设计越单一，越好呢？说出你的缘由和论证的思路想法？
- 04.单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？



#### 2.2 如何理解单一职责
- 单一职责原则的定义描述非常简单，也不难理解。
    - 一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。
    - 换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。
- 举一个例子来解释一下。
    - 比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。
    - 为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。


#### 2.3 单一判断技巧
- 还有一些小技巧，从侧面上判定一个类的职责是否够单一。要更有指导意义、更具有可执行性：
    - 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
    - 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
    - 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
    - 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
    - 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。
- 不过，你可能还会有这样的疑问：
    - 在上面的判定原则中，我提到类中的代码行数、函数或者属性过多，就有可能不满足单一职责原则。那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？
    - 比较初级的工程师经常会问这类问题。实际上，这个问题并不好定量地回答，就像你问大厨“放盐少许”中的“少许”是多少，大厨也很难告诉你一个特别具体的量值。
- 专业第六感觉
    - 实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。
    - 实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。




### 03.开放封闭原则介绍
#### 3.1 先思考几个问题
- 01.什么叫作开闭原则，他的主要用途是什么？
- 02.如何做到拓展开放，修改封闭这一准则，结合案例说一下如何实现？


#### 3.2 看一个案例改造
- 将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展？
    - 看看下面这段代码，改编某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？
    ```
    public class VIPCenter {
        void serviceVIP(T extend User user>) {
         if (user instanceof SlumDogVIP) {
            // 穷 X VIP，活动抢的那种
            // do somthing
          } else if(user instanceof RealVIP) {
            // do somthing
          }
          // ...
    }
    ```
    - 这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。
- 利用开关原则，可以尝试改造为下面的代码。
    - 将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    ```
    public class VIPCenter {
        private Map<User.TYPE, ServiceProvider> providers;
        void serviceVIP(T extend User user） {
            providers.get(user.getType()).service(user);
        }
    }
    
    interface ServiceProvider{
        void service(T extend User user) ;
    }
    
    class SlumDogVIPServiceProvider implements ServiceProvider{
        void service(T extend User user){
            // do somthing
        }
    }
    
    class RealVIPServiceProvider implements ServiceProvider{
        void service(T extend User user) {
            // do something
        }
    }
    ```


#### 3.3 开放封闭总结下
- 1.如何理解“对扩展开放、对修改关闭”？
    - 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
    - 关于定义，有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。
- 2.如何做到“对扩展开放、修改关闭”？
    - 我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。
- 3.学习设计原则，要多问个为什么。
    - 不能把设计原则当真理，而是要理解设计原则背后的思想。搞清楚这个，比单纯理解原则讲的是啥，更能让你灵活应用原则。



### 04.里式替换原则介绍
#### 4.1 先思考几个问题
- 01.什么是里氏替换的原则，如何理解这一原则？
- 02.有那些场景满足里氏替换原则？它跟多态有何区别？


#### 4.2 看一个案例分析
- 通过一个例子来解释一下。
    - 如下代码中，父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息。
    ``` java
    public class Transporter {
      private HttpClient httpClient;
      
      public Transporter(HttpClient httpClient) {
        this.httpClient = httpClient;
      }
    
      public Response sendRequest(Request request) {
        // ...use httpClient to send request
      }
    }
    
    public class SecurityTransporter extends Transporter {
      private String appId;
      private String appToken;
    
      public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {
        super(httpClient);
        this.appId = appId;
        this.appToken = appToken;
      }
    
      @Override
      public Response sendRequest(Request request) {
        if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
          request.addPayload("app-id", appId);
          request.addPayload("app-token", appToken);
        }
        return super.sendRequest(request);
      }
    }
    
    public class Demo {    
      public void demoFunction(Transporter transporter) {    
        Reuqest request = new Request();
        //...省略设置request中数据值的代码...
        Response response = transporter.sendRequest(request);
        //...省略其他逻辑...
      }
    }
    
    // 里式替换原则
    Demo demo = new Demo();
    demo.demofunction(new SecurityTransporter(/*省略参数*/););
    ```
- 在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。
- 不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？
    - 多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？
- 我们还是通过刚才这个例子来解释一下。
    - 我们需要对 SecurityTransporter 类中 sendRequest() 函数稍加改造一下。改造前，如果 appId 或者 appToken 没有设置，我们就不做校验。
    - 改造后，如果 appId 或者 appToken 没有设置，则直接抛出 NoAuthorizationRuntimeException 未授权异常。改造前后的代码对比如下所示：
    ``` java
    // 改造后：
    public class SecurityTransporter extends Transporter {
      //...省略其他代码..
      @Override
      public Response sendRequest(Request request) {
        if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {
          throw new NoAuthorizationRuntimeException(...);
        }
        request.addPayload("app-id", appId);
        request.addPayload("app-token", appToken);
        return super.sendRequest(request);
      }
    }
    ```
- 在改造之后的代码中，如果传递进 demoFunction() 函数的是父类 Transporter 对象，那 demoFunction() 函数并不会有异常抛出，但如果传递给 demoFunction() 函数的是子类 SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进 demoFunction 函数之后，整个程序的逻辑行为有了改变。
- 虽然改造之后的代码仍然可以通过 Java 的多态语法，动态地用子类 SecurityTransporter 来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。



#### 4.3 里式替换总结一下
- 里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。
    - 理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
- 要弄明白里式替换原则跟多态的区别。
    - 虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。



### 05.依赖倒置原则介绍
#### 5.1 先思考几个问题



#### 5.2 看一个案例分析



#### 5.3 接口分离总结一下




### 06.接口分离原则介绍
#### 6.1 先思考几个问题
- 01.什么叫作接口隔离法则，它和面向对象中的接口有何区别？


#### 6.2 看一个案例分析



#### 6.3 接口分离总结一下




### 07.迪米特法则的介绍
#### 7.1 先思考几个问题
- 1.什么是迪米特原则，这个原则如何理解，如何运用到实际开发，举例说明一下？
- 2.什么是高内聚松耦合，能否举例说明一下？如何利用迪米特法则来实现“高内聚、松耦合”？


#### 7.2 什么叫迪米特法则
- 迪米特法则也叫最小知识原则
    - 每个模块（unit）只应该了解那些与它关系密切的模块的有限知识。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。
- 大部分设计原则和思想都非常抽象。结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。
    - 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。



#### 7.3 何为高内聚松耦合
- “高内聚、松耦合”是一个非常重要的设计思想
    - 能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。
- “高内聚、松耦合”是一个比较通用的设计思想
    - 可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。
    - 在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。
    - 不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
- 什么是“高内聚”呢？
    - 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。
    - 实际上，前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。
- 什么是“松耦合”？
    - 所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。
    - 实际上，前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及讲的迪米特法则，都是为了实现代码的松耦合。
















