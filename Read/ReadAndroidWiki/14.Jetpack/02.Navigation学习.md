#### 目录介绍
- 01.Navigation介绍
- 02.Navigation实战必备
    - 2.1 学习方式
    - 2.2 实战必备
- 03.简单实践操作
    - 3.1 最关键的三要素
    - 3.2 举个通俗案例
    - 3.3 关键的步骤流程
- 04.Navigation深度理解
    - 4.1 Navigation架构图
    - 4.2 Navigation源码UML
    - 4.3 


### 01.Navigation介绍
- Navigation是一个可简化Android导航的库和插件
    - 更确切的来说，Navigation是用来管理Fragment的切换，并且可以通过可视化的方式，看见App的交互流程。
- 优点
    - 处理Fragment的切换，默认情况下正确处理Fragment的前进和后退
    - 为过渡和动画提供标准化的资源
    - 实现和处理深层连接
    - 可以绑定Toolbar、BottomNavigationView和ActionBar等
    - SafeArgs（Gradle插件） 数据传递时提供类型安全性
    - ViewModel支持


### 02.Navigation实战必备
#### 2.1 学习方式
- 最好的学习方式仍然是通过官方文档，下面是官方的学习地址：
    - 谷歌官方教程：[Navigation Codelab](https://codelabs.developers.google.com/codelabs/android-navigation/#0)
    - 谷歌官方文档：[Navigation](https://developer.android.com/guide/navigation/)
    - 官方Demo：[Demo地址](https://github.com/googlecodelabs/android-navigation)
- 这个教程Demo的优势
    - 官方为这个Demo提供了 **一系列详细的教程**，通过一步步，引导学习每一个类或者组件的应用场景，最终完全上手 **Navigation**。


### 03.Navigation实战必备
#### 3.1 最关键的三要素
- Navigation Graph(New XML resource)	
    - 如我们的第一张图所示，这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系。
- NavHostFragment(Layout XML view)	
    - 当前Fragment的容器
- NavController(Kotlin/Java object)	
    - 导航的控制者



#### 3.2 举个通俗案例
- 可以将Navigation Graph看作一个地图，NavHostFragment看作一个车，以及把NavController看作车中的方向盘。
- Navigation Graph中可以看出各个地点（Destination）和通往各个地点的路径，NavHostFragment可以到达地图中的各个目的地，但是决定到什么目的地还是方向盘NavController，虽然它取决于开车人（用户）。


#### 3.3 关键的步骤流程
- 第一步依赖相关库
    - 直接依赖即可
- 第二步创建navigation导航
    - 资源文件res目录下创建navigation目录 -> 右击navigation目录New一个Navigation resource file
    - 创建一个Destination，如果说navigation是我们的导航工具，Destination是我们的目的地
- 第三步建立NavHostFragment
    - 创建一个布局文件，需要是fragment，
    ```
    <androidx.constraintlayout.widget.ConstraintLayout
        ...>
    
        <fragment
            android:id="@+id/login_nav_host_fragment"
            android:name="androidx.navigation.fragment.NavHostFragment"
            app:navGraph="@navigation/login_navigation"
            app:defaultNavHost="true"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>
    
    </androidx.constraintlayout.widget.ConstraintLayout>
    ```
    - android:name	：值必须是androidx.navigation.fragment.NavHostFragment，声明这是一个NavHostFragment
    - app:navGraph	：存放的是第二步建好导航的资源文件，也就是确定了Navigation Graph
    - app:defaultNavHost="true"	：与系统的返回按钮相关联
- 第四步界面跳转和传参
    - 方式一 利用ID导航：findNavController().navigate(R.id.login, bundle,navOption)
    - 方式二 利用Safe Args：
- action标签
    - app:destination	跳转完成到达的fragment的Id
    - app:popUpTo	将fragment从栈中弹出，直到某个Id的fragment
- argument标签
    - android:name	标签名字
    - app:argType	标签的类型
    - android:defaultValue	默认值
- WelcomeFragment中的JOIN US按钮点击事件：
    ```
    btnRegister.setOnClickListener {
        val action = WelcomeFragmentDirections
            .actionWelcomeToRegister()
            .setEMAIL("TeaOf1995@Gamil.com")
        findNavController().navigate(action)
    }
    ```
- RegisterFragment中的接收：
    ```
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            // ...
            val safeArgs:RegisterFragmentArgs by navArgs()
            val email = safeArgs.email
            mEmailEt.setText(email)
    }
    ```
- 如果不用Safe Args，action可以由 Navigation.createNavigateOnClickListener(R.id.next_action, null)方式生成



### 04.Navigation深度理解
- 先思考这样一个问题：**如果让我们实现一个Fragment的导航库，首先要实现什么？**



#### 4.1 Navigation架构图
- `NavGraphFragment`是什么：导航界面的容器
    - 主要是承载fragment的一个容易，其实就是一个拓展fragment。
- `nav_graph.xml`是什么：声明导航结构图
    - `NavGraphFragment` **获取** 并 **解析** 完这个xml资源文件后，然后做逻辑处理
- 一些标签的作用
    - `action`标签是什么：声明导航的行为，比如id，通过id可以执行跳转到对应的页面；如果destination，声明行为导航的目的地
    - `argument`标签是什么：跳转参数的设置，name表示参数key，argType表示参数类型，defaultValue表示默认值
- NavController是什么：跳转导航页面的操作
    - 通过调用navigate方法，跳转页面，相当于路由



#### 4.3 NavGraphFragment
- `NavGraphFragment`是什么：导航界面的容器
    - 使用原生的API，想展示一个Fragment，我们首先也需要 **定义一个容器承载它**。以往，它可能是一个 **RelativeLayout** 或者 **FrameLayout**，而现在，它被替换成了 **NavGraphFragment**。

这也就说明了，我们为什么要往Activity的layout文件中提前扔进去一个NavGraphFragment，因为我们需要导航的这些Fragment都展示在NavGraphFragment上面。

实际上它做了什么呢？来看一下NavGraphFragment的onCreateView()方法：

```Java
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        FrameLayout frameLayout = new FrameLayout(inflater.getContext());
        frameLayout.setId(getId());
        return frameLayout;
    }
```
NavGraphFragment内部实例化了一个FrameLayout, **作为ViewGroup的载体，导航并展示其它Fragment**。

除此之外，你 **应当注意** 到在layout文件中，它还声明了另外两个属性：

>  app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph_main"

app:defaultNavHost="true"这个属性意味着你的NavGraphFragment将会 **拦截系统Back键的点击事件**（因为系统的back键会直接关闭Activity而非切换Fragment），你同时 **必须重写** Activity的 **onSupportNavigateUp()** 方法，类似这样：

```Kotlin
override fun onSupportNavigateUp()
        = findNavController(R.id.nav_host_fragment).navigateUp()
```
app:navGraph="@navigation/nav_graph_main"这个属性就很好理解了，它会指向一个navigation_graph的xml文件,这之后，NavGraphFragment就会 **导航并展示对应的Fragment**。

在我们使用Navigation的第一步，我们需要：

>  **在Activity的布局文件中显示声明NavGraphFragment，并配置 app:defaultNavHost 和 app:navGraph属性**。

#### 4.4 nav_graph.xml
- `nav_graph.xml`是什么：声明导航结构图

NavGraphFragment作为Activity导航的 **容器** ，然后，其 **app:navGraph** 属性指向一个navigation_graph的xml文件，以声明其 **导航的结构**。

NavGraphFragment在 **获取** 并 **解析** 完这个xml资源文件后，它首先需要知道的是：

> 类似APP的home界面，NavGraphFragment首先要导航到哪里?

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    app:startDestination="@id/page1Fragment">

    <fragment
        android:id="@+id/page1Fragment"
        android:name="com.qingmei2.samplejetpack.ui.main.MainPage1Fragment"
        android:label="fragment_page1"
        tools:layout="@layout/fragment_main_page1">
        <action
            android:id="@+id/action_page2"
            app:destination="@id/page2Fragment" />
    </fragment>
    //省略...
</navigation>
```

在navigation的根节点下，我们需要处理这样一个属性：

> app:startDestination="@id/page1Fragment"

**Destination** 是一个很关键的单词，它的直译是 **目的地**。**app:startDestination**属性便是声明这个id对应的 **Destination** 会被作为 **默认布局** 加载到Activity中。这也就说明了，为什么我们的sample，默认会显示 **MainPage1Fragment**。

现在，我们的app默认展示了MainPage1Fragment, 那么接下来，我们如何实现跳转逻辑的处理呢？



#### 4.5 Action标签
Action标签是什么：声明导航的行为

我们声明了这样一个Action标签，这是一个 **导航的行为**：

```xml
<action
    android:id="@+id/action_page2"
    app:destination="@id/page2Fragment" />
```
**app:destination**的属性，声明了这个行为导航的 **destination（目的地）**，我们可以看到，它会指定跳转到 id 为 **page2Fragment** 的Fragment（也就是 **MainPage2Fragment**）。

**android:id** 这个id作为Action唯一的 **标识**，在Fragment的某个点击事件中，我们通过id指向**对应的行为**，就像这样：

```Kotlin
btn.setOnClickListener {
       //点击跳转page2Fragment
       Navigation.findNavController(it).navigate(R.id.action_page2)
}
```
此外，Navigation还提供了一个 **app:popUpTo** 属性，它的作用是声明**导航行为** 将 **返回到** id对应的Fragment，比如，直接从Page3 返回到 Page1。

此外，Navigation 对导航行为还提供了 **转场动画** 的支持，它可以通过代码这样实现：

```xml
<action
        android:id="@+id/confirmationAction"
        app:destination="@id/confirmationFragment"
        app:enterAnim="@anim/slide_in_right"
        app:exitAnim="@anim/slide_out_left"
        app:popEnterAnim="@anim/slide_in_left"
        app:popExitAnim="@anim/slide_out_right" />
```

> 篇幅原因，这些anim的xml文件我并未展示在文中，如有需求，请参考[Sample代码](https://github.com/qingmei2/SampleNavigation)。

其实Navigation 还提供了对Destination之间 **参数传递** 的支持，以及对SubNavigation标签的支持，以方便开发者在xml文件中 **复用fragment标签** ——甚至是对 **Deep Link** 的支持，但这些拓展功能本文不再叙述。

### 4.Fragment：通过代码声明导航

其实在3中我们已经讲解了导航代码的使用,我们以Page2为例，它包含了2个按钮，分别对应 **返回Page1** 和 **进入Page3** 两个事件：

```
btn.setOnClickListener {
      Navigation.findNavController(it).navigateUp()
}
btn2.setOnClickListener {
      Navigation.findNavController(it).navigate(R.id.action_page3)
}
```
Navigation.findNavController(View) 返回了一个 **NavController** ,它是整个 **Navigation** 架构中 **最重要的核心类**，我们所有的导航行为都由 **NavController** 处理，这个我们后面再讲。

我们通过获取 **NavController**，然后调用  NavController.navigate()方法进行导航。

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.37y62a1uqz8.png)

我们更多情况下通过传入ActionId，指定对应的 **导航行为** ；同时可以通过传入Bundle以 **数据传递**；或者是再传入一个 **NavOptions**配置更多（比如 **转场动画**，它也可以通过这种方式进行代码的动态配置）。

NavController.navigate()方法更多时候应用在 **向下导航** 或者 **指定向上导航**（比如Page3 直接返回 Page1，跳过返回Page2的这一步）；如果我们处理back事件，我们应该使用 **NavController.
navigateUp()**。

### 恭喜您，已经能够游刃有余的使用Navigation!

恭喜您，您已对 **Navigation** 十分熟悉，并能通过熟练使用其 **暴露的API**，灵活地处理您应用中的 **页面导航** 行为。

我美滋滋的在个人履历上填上了这样一条：

* 熟练使用Google官方组件Navigation实现Fragment的管理，并掌握其原理

面试官对此十分感动，然后让我谈谈 **对它架构设计的一些个人观点**。

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.5m727974xxi.png)

到了这一步，我们算得上是 **API的搬运工** ，我们已经 **了解每一个类的职责**，还没有完全 **理解框架设计者的思想**。













### 3.尝试使用Navigation

>  #### **Navigation目前仅AndroidStudio 3.2以上版本支持，如果您的版本不足3.2，请[点此下载](https://developer.android.com/studio/preview/)预览版AndroidStudio**

首先介绍Navigation的使用：

> 无论是否认可，我们都必须承认，Google已经在尝试让Kotlin上位，无论是今年IO大会的 **数据展示**，还是官方文档上的 **代码示例片段**，亦或是Google最新 **开源Demo的源码**，使用语言清一色 Kotlin，本文亦然。

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.chu8p4gmabr.png)


#### ① 在Module下的build.gradle中添加以下依赖：
```groovy
dependencies {
    def nav_version = '1.0.0-alpha01'
    implementation "android.arch.navigation:navigation-fragment:$nav_version"
    implementation "android.arch.navigation:navigation-ui:$nav_version"
}
```
#### ② 新建三个Fragment：

```kotlin
//3个Fragment，它们除了layout不同，没有其它区别
class MainPage1Fragment : Fragment() {

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View {
        return inflater.inflate(R.layout.fragment_main_page1, container, false)
    }
}

class MainPage2Fragment : Fragment() {

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_main_page2, container, false)
    }
}

class MainPage3Fragment : Fragment() {

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_main_page3, container, false)
    }
}
```
#### ③ 新建导航视图文件（nav_graph）

在res目录下新建navigation文件夹，然后新建一个navigation的resource文件，我叫它 **nav_graph_main.xml** ：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.0zd07r5mc4vg.png)

打开导航视图文件，我们可以在AndroidStudio 3.2版本上，进行可视化编辑，包括选择新增Fragment，或者拖拽，连接Fragment：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.xq10dlbi0co.png)

#### ④ 编辑导航视图文件

我们打开Text标签，进入xml编辑的页面，并这样配置:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    app:startDestination="@id/page1Fragment">

    <fragment
        android:id="@+id/page1Fragment"
        android:name="com.qingmei2.samplejetpack.ui.main.MainPage1Fragment"
        android:label="fragment_page1"
        tools:layout="@layout/fragment_main_page1">
        <action
            android:id="@+id/action_page2"
            app:destination="@id/page2Fragment" />
    </fragment>

    <fragment
        android:id="@+id/page2Fragment"
        android:name="com.qingmei2.samplejetpack.ui.main.MainPage2Fragment"
        android:label="fragment_page2"
        tools:layout="@layout/fragment_main_page2">
        <action
            android:id="@+id/action_page1"
            app:popUpTo="@id/page1Fragment" />
        <action
            android:id="@+id/action_page3"
            app:destination="@id/nav_graph_page3" />
    </fragment>

    <navigation
        android:id="@+id/nav_graph_page3"
        app:startDestination="@id/page3Fragment">
        <fragment
            android:id="@+id/page3Fragment"
            android:name="com.qingmei2.samplejetpack.ui.main.MainPage3Fragment"
            android:label="fragment_page3"
            tools:layout="@layout/fragment_main_page3" />
    </navigation>

</navigation>
```

**注意**：请保证fragment标签下，android:name属性内包名的正确声明。

#### ⑤ 编辑MainActivity

在Activity中配置 Navigation **非常简单**，我们首先编辑Activity的布局文件，并在布局文件中添加一个 **NavHostFragment** :

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <fragment
        android:id="@+id/my_nav_host_fragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph_main" />

</android.support.constraint.ConstraintLayout>
```
这是一个宽和高都 match_parent 的Fragment，它的作用就是 **导航界面的容器**。

这并不难以理解，我们需要在Activity中通过 Navigation **展示一系列的Fragment**，但是我们需要告诉Navigation 和Activity，这一系列的 Fragment **展示在哪**——NavHostFragment应运而生，我把它的作用归纳为 **导航界面的容器**。

这之后，在Activity中添加如下代码：

```Kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onSupportNavigateUp() =
            findNavController(this, R.id.my_nav_host_fragment).navigateUp()
}
```

onSupportNavigateUp()方法的重写，意味着Activity将它的 **back键点击事件的委托出去**，如果当前并非栈中顶部的Fragment, 那么点击back键，返回上一个Fragment。

#### ⑥ 最后，配置不同Fragment对应的跳转事件

```Kotlin
class MainPage1Fragment : Fragment() {
     //隐藏了onCreateView()方法的实现，下同
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btn.setOnClickListener {
            //点击跳转page2
            Navigation.findNavController(it).navigate(R.id.action_page2)
        }
    }
}

class MainPage2Fragment : Fragment() {

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btn.setOnClickListener {
           //点击返回page1
            Navigation.findNavController(it).navigateUp()
        }
        btn2.setOnClickListener {
            //点击跳转page3
            Navigation.findNavController(it).navigate(R.id.action_page3)
        }
    }
}

class MainPage3Fragment : Fragment() {

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        //点击返回page2
        btn.setOnClickListener { Navigation.findNavController(it).navigateUp() }
    }
}
```

可以看到，我们对于Fragment 并非是通过原生的 **FragmentManager** 和 **FragmentTransaction** 进行控制的。而是通过以下API进行的控制：

* **Navigation.findNavController(params).navigateUp()**
* **Navigation.findNavController(params).navigate(actionId)**

> 到这里，Navigation最基本的使用就已经讲解完毕了。您可以通过运行预览和示例 **基本一致** 的效果，如果遇到问题，或者有疑问，可以[点我查看源码](https://github.com/qingmei2/SampleNavigation) 。



## 彻底搞懂Navigation

在我们熟悉Navigation的API之后，我们整装待发，准备 **源码级攻克** Navigation。

> 正如我所说的，在这之前，您首先需要达到 **熟练使用Navigation**，本文地初衷并非是 **一步到位**，而是尝试 **循序渐进**。

### 1.对源码分析说NO

**声明** —— 我拒绝 **大段大段地源码分析**，我认为这种行为 **严重降低** 了文章的 **质量** 和 **深度**。

我花了一些时间绘制了 **Navigation的UML类图**，我坚信，这种方式能帮助你我 **更深刻的理解** Navigation的整体架构：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/navigation/image.f9gw6e58lf.png)

让我们换个角度，我们的身份不再是 **源码的观众**，而是 **架构的设计者**。

### 2.  设计 NavHostFragment

NavHostFragment 应当有两个作用：

* 作为Activity导航界面的载体
* **管理并控制导航的行为**

前者的作用我们已经说过了，我们通过在NavHostFragment的创建时，为它创建一个对应的FrameLayout作为 **导航界面的载体**：

```
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        FrameLayout frameLayout = new FrameLayout(inflater.getContext());
        frameLayout.setId(getId());
        return frameLayout;
    }
```

我们都知道代码设计应该遵循 **单一职责原则**，因此，我们应该将 **管理并控制导航的行为** 交给另外一个类，这个类的作用应该仅是 **控制导航行为**，因此我们命名为 **NavController**。

Fragment理应持有这个**NavController**的实例，并将导航行为 **委托** 给它，这里我们将 **NavController** 的持有者抽象为一个 **接口**，以便于以后的拓展。

于是我们创造了 **NavHost** 接口，并让NavHostFragment实现了这个接口：

```Java
public interface NavHost {

    NavController getNavController();
}
```

为了保证导航的 **安全**，NavHostFragment 在其 **作用域** 内，理应 **有且仅有一个NavController 的实例**。

这里我们驻足一下，请注意API的设计，似乎 Navigation.findNavController(View)，参数中传递任意一个 view的引用似乎都可以获取 **NavController**——如何保证 **NavController 的局部单例**呢？

事实上，findNavController(View)内部实现是通过 **遍历** View树，直到找到最底部 **NavHostFragment** 中的**NavController**对象，并将其返回的：

```
private static NavController findViewNavController(@NonNull View view) {
        while (view != null) {
            NavController controller = getViewNavController(view);
            if (controller != null) {
                return controller;
            }
            ViewParent parent = view.getParent();
            view = parent instanceof View ? (View) parent : null;
        }
        return null;
  }
```

### 3.设计 NavController

站在 **设计者** 的角度，**NavController** 的职责是：

* 1.对navigation资源文件夹下nav_graph.xml的 **解析**
* 2.通过解析xml，获取所有 **Destination**（目标点）的 **引用** 或者 **Class的引用**
* 3.记录当前栈中 **Fragment的顺序**
* 3.管理控制 **导航行为**

**NavController** 持有了一个 **NavInflater** ,并通过 **NavInflater** 解析xml文件。

这之后，获取了所有 **Destination**（在本文中即**Page1Fragment** , **Page2Fragment** , **Page3Fragment** ） 的 Class对象，并通过反射的方式，实例化对应的 **Destination**，通过一个队列保存：

```
    private NavInflater mInflater;  //NavInflater
    private NavGraph mGraph;        //解析xml，得到NavGraph
    private int mGraphId;           //xml对应的id，比如 nav_graph_main
    //所有Destination的队列,用来处理回退栈
    private final Deque<NavDestination> mBackStack = new ArrayDeque<>();   
```

这看起来没有任何问题，但是站在 **设计者** 的角度上，还略有不足，那就是，**Navigation并非只为Fragment服务**。

先不去吐槽Google工程师的野心，因为现在我们就是他，从拓展性的角度考虑，Navigation是一个导航框架，今后可能 **并非只为Fragment导航**。

我们应该为要将导航的 **Destination**  抽象出来，这个类叫做 **NavDestination** ——无论 **Fragment** 也好，**Activity** 也罢，只要实现了这个接口，对于**NavController** 来讲，他们都是 **Destination(目标点)** 而已。

对于不同的 **NavDestination** 来讲，它们之间的导航方式是不同的，这完全有可能（比如Activity 和 Fragment），如何根据不同的 **NavDestination** 进行不同的 **导航处理** 呢？

#### 4. NavDestination 和 Navigator

有同学说，我可以这样设计，通过 instanceof 关键字，对 **NavDestination** 的类型进行判断，并分别做出处理，比如这样：

```
if (destination instanceof Fragment) {
  //对应Fragment的导航
} else if (destination instanceof Activity) {
  //对应Activity的导航
}
```

这是OK的，但是不够优雅，Google的方式是通过抽象出一个类，这个类叫做 **Navigator** ：

```
public abstract class Navigator<D extends NavDestination> {
    //省略很多代码,包括部分抽象方法，这里仅阐述设计的思路！

    //导航
    public abstract void navigate(@NonNull D destination, @Nullable Bundle args,
                                     @Nullable NavOptions navOptions);
    //实例化NavDestination（就是Fragment）
    public abstract D createDestination();

    //后退导航
    public abstract boolean popBackStack();
}
```

**Navigator**(导航者) 的职责很单纯：

* 1.能够实例化对应的 **NavDestination**
* 2.能够指定导航
* 3.能够后退导航

你看，我的 **NavController** 获取了所有 **NavDestination** 的Class对象，但是我不负责它 **如何实例化** ，也不负责 **如何导航** ，也不负责
 **如何后退** ——我仅仅持有向上的引用，然后调用它的接口方法，它的实现我不关心。

以 **FragmentNavigator**为例，我们来看看它是如何执行的职责：

```
public class FragmentNavigator extends Navigator<FragmentNavigator.Destination> {
    //省略大量非关键代码，请以实际代码为主！

    @Override
    public boolean popBackStack() {
        return mFragmentManager.popBackStackImmediate();
    }

    @NonNull
    @Override
    public Destination createDestination() {
        // 实际执行了好几层，但核心代码如下，通过反射实例化Fragment
        Class<? extends Fragment> clazz = getFragmentClass();
        return  clazz.newInstance();
    }

    @Override
    public void navigate(@NonNull Destination destination, @Nullable Bundle args,
                            @Nullable NavOptions navOptions) {
        // 实际上还是通过FragmentTransaction进行的跳转处理
        final Fragment frag = destination.createFragment(args);
        final FragmentTransaction ft = mFragmentManager.beginTransaction();
        ft.replace(mContainerId, frag);
        ft.commit();
        mFragmentManager.executePendingTransactions();
    }
}
```

不同的 **Navigator** 对应不同的 **NavDestination**，**FragmentNavigator** 对应的是 **FragmentNavigator.Destination**，你可以把他理解为案例中的 **Fragment** ，有兴趣的朋友可以自己研究一下。

#### 5.至此

至此，Navigation 整体的架构设计 也已经通过 **UML类图** + **设计的角度分析** 的方式学习完了。

当然，Navigation 还有很多其它的类我没有去阐述，它们已经无法阻拦你我的脚步。

我更建议 读者在这之后，能够尝试自己阅读源码，通过借鉴上文中的 **UML类图**，当然，自己通过思路的整理，自己绘制出一份，会对理解它更有帮助。

## 总结

**Navigation** 是一个优秀的库，这从API上无法体现，因为它和其它优秀的三方 Fragment 管理库 都能达到 **固定的目标**。

并且，随着技术的不断发展，它们也早晚会被历史所淹没，我们能够做到的，就是使用API的同时，**学习它的思想，并收为己用**。

**--------------------------广告分割线------------------------------**

## 系列文章

>  **争取打造 Android Jetpack 讲解的最好的博客系列**：
>* [Android官方架构组件Lifecycle：生命周期组件详解&原理分析](https://juejin.im/post/5c53beaf51882562e27e5ad9)
>* [Android官方架构组件ViewModel:从前世今生到追本溯源](https://juejin.im/post/5c047fd3e51d45666017ff86)
>* [Android官方架构组件LiveData: 观察者模式领域二三事](https://juejin.im/post/5c25753af265da61561f5335)
>* [Android官方架构组件Paging：分页库的设计美学](https://juejin.im/post/5c53ad9e6fb9a049eb3c5cfd)
>* [Android官方架构组件Paging-Ex：为分页列表添加Header和Footer](https://juejin.im/post/5caa0052f265da24ea7d3c2c)
>* [Android官方架构组件Paging-Ex：列表状态的响应式管理](https://juejin.im/post/5ce6ba09e51d4555e372a562)
>* [Android官方架构组件Navigation：大巧不工的Fragment管理框架](https://juejin.im/post/5c53be3951882562d27416c6)  
>* [Android官方架构组件DataBinding-Ex:双向绑定篇](https://juejin.im/post/5c3e04b7f265da611b589574)  

> **Android Jetpack 实战篇**：
>* [开源项目：MVVM+Jetpack实现的Github客户端](https://github.com/qingmei2/MVVM-Rhine)
>* [开源项目：基于MVVM, MVI+Jetpack实现的Github客户端](https://github.com/qingmei2/MVI-Rhine)
>* [总结：使用MVVM尝试开发Github客户端及对编程的一些思考](https://juejin.im/post/5be7bbd9f265da61797458cf)

---

## 关于我

Hello，我是[却把清梅嗅](https://github.com/qingmei2)，如果您觉得文章对您有价值，欢迎 ❤️，也欢迎关注我的[个人博客](https://juejin.im/user/588555ff1b69e600591e8462)或者[Github](https://github.com/qingmei2)。

如果您觉得文章还差了那么点东西，也请通过**关注**督促我写出更好的文章——万一哪天我进步了呢？

* [我的Android学习体系](https://github.com/qingmei2/android-programming-profile)
* [关于文章纠错](https://github.com/qingmei2/Programming-life/blob/master/error_collection.md)
* [关于知识付费](https://github.com/qingmei2/Programming-life/blob/master/appreciation.md)




# 参考
- http://t.zoukankan.com/guanxinjing-p-12344572.html

