#### 目录介绍
- 01.并发设计模式介绍
    - 1.1 不可变解决并发
    - 1.2 COW解决并发
- 02.不变性模式解读
    - 2.1 解决并发问题
    - 2.2 实现不可变性的类
    - 2.3 Java SDK不可变类
    - 2.4 不可变修改操作
    - 2.5 享元模式的优化
    - 2.6 Immutability注意点



### 02.不变性模式解读
#### 2.1 解决并发问题
- 多线程并发问题
    - “多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。
- 如何快速解决并发问题
    - 最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：不变性（Immutability）模式。
    - 所谓不变性，简单来讲，**对象一旦被创建之后，状态就不再发生变化**。换句话说，就是**变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性**。


#### 2.2 实现不可变性的类
- 实现一个具备不可变性的类。
    - 将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。
    - 更严格的做法是这个类本身也是 final 的，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法。



#### 2.3 Java SDK不可变类
- SDK 里很多类都具备不可变性。
    - 例如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。
    - 如果你仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。
- Java 的 String 方法也有类似字符替换操作，怎么能说所有方法都是只读的呢？
    - 结合 String 的源代码来解释一下这个问题，下面的示例代码源自 Java 1.8 SDK，仅保留了关键属性 value[]和 replace() 方法
    - 你会发现：String 这个类以及它的属性 value[]都是 final 的；而 replace() 方法的实现，就的确没有修改 value[]，而是将替换后的字符串作为返回值返回了。
    ```java
    public final class String {
      private final char value[];
      // 字符替换
      String replace(char oldChar, 
          char newChar) {
        //无需替换，直接返回this  
        if (oldChar == newChar){
          return this;
        }
    
        int len = value.length;
        int i = -1;
        /* avoid getfield opcode */
        char[] val = value; 
        //定位到需要替换的字符位置
        while (++i < len) {
          if (val[i] == oldChar) {
            break;
          }
        }
        //未找到oldChar，无需替换
        if (i >= len) {
          return this;
        } 
        //创建一个buf[]，这是关键
        //用来保存替换后的字符串
        char buf[] = new char[len];
        for (int j = 0; j < i; j++) {
          buf[j] = val[j];
        }
        while (i < len) {
          char c = val[i];
          buf[i] = (c == oldChar) ? 
            newChar : c;
          i++;
        }
        //创建一个新的字符串返回
        //原字符串不会发生任何变化
        return new String(buf, true);
      }
    }
    ```
- 如果具备不可变性的类，需要提供类似修改的功能，具体该怎么操作呢？
    - 做法很简单，那就是创建一个新的不可变对象，这是与可变对象的一个重要区别，可变对象往往是修改自己的属性。
    - 所有的修改操作都创建一个新的不可变对象，你可能会有这种担心：是不是创建的对象太多了，有点太浪费内存呢？是的，这样做的确有些浪费，那如何解决呢？可以用享元模式



#### 2.5 享元模式的优化
- 利用享元模式可以减少创建对象的数量，从而减少内存占用。
    - Java 语言里面 Long、Integer、Short、Byte 等这些基本数据类型的包装类都用到了享元模式。
    - 以 Long 这个类作为例子，看看它是如何利用享元模式来优化对象的创建的。
- 享元模式本质上其实就是一个对象池
    - 利用享元模式创建对象的逻辑也很简单：创建之前，首先去对象池里看看是不是存在；如果已经存在，就利用对象池里的对象；如果不存在，就会新创建一个对象，并且把这个新创建出来的对象放进对象池里。
- Long 这个类并没有照搬享元模式
    - Long 内部维护了一个静态的对象池，仅缓存了(-128,127)之间的数字，这个对象池在 JVM 启动的时候就创建好了，而且这个对象池一直都不会变化，也就是说它是静态的。
    - 之所以采用这样的设计，是因为 Long 这个对象的状态共有 264 种，实在太多，不宜全部缓存，而(-128,127)之间的数字利用率最高。


#### 2.6 Immutability注意点
- 在使用 Immutability 模式的时候，需要注意以下两点：
    - 对象的所有属性都是 final 的，并不能保证不可变性；
    - 不可变对象也需要正确发布。
- 在 Java 语言中，final 修饰的属性一旦被赋值，就不可以再修改，但是如果属性的类型是普通对象，那么这个普通对象的属性是可以被修改的。
    - 例如下面的代码中，Bar 的属性 foo 虽然是 final 的，依然可以通过 setAge() 方法来设置 foo 的属性 age。
    - 所以，在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。
    ```java
    class Foo{
      int age=0;
      int name="abc";
    }
    final class Bar {
      final Foo foo;
      void setAge(int a){
        foo.age=a;
      }
    }
    ```









