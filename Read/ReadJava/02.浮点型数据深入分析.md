#### 目录介绍
- 01.先看一个案例
- 02.浮点数判断
- 05.看一个面试题
- 06.精度为何丢失
- 07.float和double
- 08.浮点型表示法


### 01.先看一个案例
- 先看一个案例，思考一下是否妥当
    - 下面这个案例。用 == 从语法上说没错，但是本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用==就会认为它们不等。
    ``` java
    float a = 2.0000001f
    float b = 2.0000001f
    if(a==b){
  
    }
    ```


### 02.浮点数判断
- 浮点数判断需要注意，float和double的精度范围，超过范围的数字会被忽略
    - (1) 浮点数大小判断：如果没有等号关系在里面，也就必然一大一小，那么直接用  > 或者 <
    - (2) 浮点数相等判断：因为浮点数在内存中存放，可能无法精确的储存，所以同一个值，可能有不同的内存数据
- 正确做法
    - 应该使用两个浮点数之间的差异的绝对值小于某个可以接受的值来判断判断它们是否相等
    ``` java
    private static final float EQUAL_FLOAT = 0.0000001f;
    if (Math.abs(a-b)> EQUAL_FLOAT && Math.abs(b-a)> EQUAL_FLOAT){
        
    }
    ```



### 05.看一个面试题
- 题目
    ``` java
    float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true
    ```
- 测试代码
    ``` java
    float f = 1.4f;
    double d = 1.4d;
    float f1 = 1.5f;
    double d1 = 1.5d;
    
    while (true) {
        System.out.println(f);
        System.out.println((double)f);
        System.out.println(d);
        System.out.println(f - d);
        System.out.println(f == d);
    
        System.out.println("--------");
        System.out.println(f1);
        System.out.println((double) f1);
        System.out.println(d1);
        System.out.println(f1 - d1);
        System.out.println(f1 == d1);
    }
    
    1.4
    1.399999976158142
    1.4
    -2.3841857821338408E-8
    false
    --------
    1.5
    1.5
    1.5
    0.0
    true
    ```
- 十进制小数如何转化为二进制数？算法是乘以2直到没有了小数为止。举个例子，0.3表示成二进制数
    ``` java
    0.3*2=0.6   取整数部分  0
    
    0.6*2=1.2   取整数部分  1
    
    0.2(1.2的小数部分)*2=0.4   取整数部分 0
    
    0.4*2=0.8   取整数部分  0
    
    0.8*2=1.6    取整数部分 1
    
    0.6*2=1.2   取整数部分  1
    
    .........     0.3二进制表示为(从上往下):0100110011...... 
    ```
- 上面的计算过程循环了，也就是说2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的。而0.5能用二进制数精确表示0.52=1.0时能取整数部分。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。


### 06.精度为何丢失
- 先看一个例子
    - 精度为什么会丢失，计算机能存那么多数字，一个0.3+0.6怎么就丢精度了呢？
    ``` java
    public static void main(String[] args){
        System.out.println(0.3f + 0.6f);
        System.out.println(0.3 + 0.6);
        System.out.println(0.9);
    }
    输出:
    
    0.90000004
    0.8999999999999999
    0.9
    ```
- 为何精度丢失
    - 在计算机中，一切皆为整数在算术类型上，又分为整数和浮点数，浮点数是由 符号位、有效数字、指数位这些整数共同构成的。但是计算机又不是使用人类的10进制，而是使用的2进制进行（指数）存储，所以理所当然的会有精度丢失。
    - 十进制。10进制中的1/3这种除法我们想表示的时候只能用0.33333....来表示，那么当我们显示的位数是固定的时候就存在精度问题，1/3！=0.33，也不等于0.333333333。假设小数点之后我们只能写8位或者16位那么久丢失了精度。
    - 二进制。所以在二进制中精度丢失也是一个道理。毕竟这种无限循环的事情，计算器不可能开辟一个无限大的空间去给你存储吧！
- 继续深入一些
    - 浮点数在计算机中的存储方式其实是以补码的形式。在计算机中，数字都是用补码来表示与存储的。
    - 正数的补码是其二进制表示的，负数的补码是其正数的二进制取反再加一。然后就是为什么0.3+0.6会导致精度丢失了。（0.3转化为二进制为0.0100110011001100）结果是保留16位的，然后导致了精度的丢失；（0.6转化为0.1001100110011001）结果是保留16位的，也导致了精度的丢失；相加起来就是0.1110011001100101再转化为十进制为0.8999786376953125和上面结果不同，但差不多应该是计算精度的不同吧。



### 07.float和double
- 为何 float 和 double 的计算输出结果差异还挺大的呢？
    - 附加题的话就是float和double所占的字节不同，他们的计算精度也不同。最关键的是保留有效数字的规则不同，十进制中我们是“4舍5入”，而二进制中是“0舍1入”。
    - 所以在上面的0.3f（转化为二进制保留8位小数是0.01001101），0.6f（转化为二进制保留8位小数是0.10011010），加起来是0.11100111，转化为十进制是0.90234375，所以 float 和 double 的计算输出结果差异还挺大的是因为保留有效数字时的“0舍1入”造成的。



### 08.浮点型表示法
- 计算机中的表示方法
    - 对于float来说，4个字节，32位，0-22位表示尾数，23-30(8位)表示指数，31位表示符号位。
    - 对于double来说，8个字节，64位，0-51表示尾数，52-62(11位)表示指数，63位最高位表示符号位。
- 具体分析表示方法
    - 以一道例题开始
    ```
    public static void main(String[] args) {
        float f1=20f;
        float f2=20.3f;
        float f3=20.5f;
    
        double d1=20;
        double d2=20.3;
        double d3=20.5;
    
        System.out.println(f1==d1);
        System.out.println(f2==d2);
        System.out.println(f3==d3);
    }
    
    true
    false
    true
    ```
- 20表示方式
    - 表示如下：注意，指数位要移位存储，即float+127(2^7-1),double+1023(2^10-1)
    ```
    f:0|1000 0011|0100 0000 0000 0000 0000 000
    d:0|100 0000 0011|0100 0000(01后面50个0)
    ```
    - 比较的时候是以符号位，指数位，小数位分别比较的，不足的地方以0补齐，所以相等，符号位均为0；指数位float减去127，并在前面补0，double减去1023；尾数位，float末尾补0。所以相等。
- 20.3表示方式
    - 1.十进制数转化为二进制数
        - 如何将十进制转换成二进制浮点数呢, 先介绍一下十进制的浮点数 转换二进制的浮点数，分为两部分：
            - 先将整数部分转换为二进制，
            - 将小数部分转换为二进制， 然后将整数部分与小数部分相加。
        - 以 20.3 转换为例
            - 20转换后变为 10100
            - 0.3要转换二进制，需要乘2，乘完之后取整数部分，然后用乘的结果减去整数部分， 然后 接着乘2, 直至最后没有小数或者小数出现循环, 即乘完.
            ```
            20 = 10100 (二进制)
            0.3 * 2= 0.6 (0)
            0.6 * 2 = 1.2 (1)
            0.2 * 2= 0.4 (0)
            0.4 * 2 = 0.8 (0)
            0.8 *2 = 1.6 (1)
            ```
        - 计算到这里， 将再出现0.6,进入循环了，所以，结果
            - 0.3 = 0.010011001…1001
            - 所以20.3 = 10100.010011001…1001 (二进制).
    - 2.二进制数转化为科学计数法
        - 20.3 = 10100.010011001…1001(二进制)=1.01000100110011E10…..（十进制科学计数）=1.01000100110011E100…..(二进制科学计数)
        - 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023)



#### 学习
- Java学习之double类型数据比较
    - https://blog.csdn.net/u012235651/article/details/73199464









