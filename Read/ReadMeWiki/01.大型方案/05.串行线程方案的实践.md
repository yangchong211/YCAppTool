#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.线程任务须知
    - 2.3 将异步转为同步




### 02.线程任务须知
#### 2.3 将异步转为同步
- 场景说明
    - 平时获取子线程返回结果以异步回调的方式获取返回到主线程，其实也可以通过某种方法转为同步返回。那么如何将这种异步回调改成同步式的回调？
- 应用场景：
    - 1.单个线程处理结果返回到主线程；2.多个子线程并发请求，最终合并返回结果到主线程
- 将异步转为同步
    - 第一种方式：使用sleep，直接在主线程睡眠，等待子线程返回。缺点：不明确子线程执行时间情况下，不一定能拿得到返回结果
    - 第二种方式：使用join，阻塞调用此方法的线程进入 TIMED_WAITING 状态，直到线程完成。
    - 第三种方式：使用Future，这是线程创建的又一种实现方式，只不过是阻塞异步的。
    - 第四种方式：使用CountDownLatch，它允许一个或多个线程等待直到在其他线程中一组操作执行完成。
    - 第五种方式：使用同步屏障CyclicBarrier，线程间同步阻塞是使用的是ReentrantLock，可重入锁。
    - 第六种方式：使用信号量Semaphore，与CountDownLatch相似，不同的地方在于Semaphore的值被获取到后是可以释放的，并不像CountDownLatch那样一直减到底。
    - 第七种方式：使用移相器Phaser，重量级并发类，jdk7被引入，用来解决控制多个线程分阶段共同完成任务的情景问题。其作用相比CountDownLatch和CyclicBarrier更加灵活。
- CountDownLatch和CyclicBarrier区别
    - CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 
    - CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待，类似有福同享，有难同当







