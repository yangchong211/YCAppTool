#### 目录介绍
- 03.Keep-Alive模式
- 05.短连接与长连接
- 06.无连接和无状态




### 03.转发和重定向
- 转发和重定向的区别是什么？
    - 转发是服务器行为，重定向是客户端行为
    - 请求次数：
        - 转发：客户端只进行了一次请求
        - 重定向：客户端进行了两次请求
    - 内部机制不同:
        - 转发: 服务端必须是在同一个web容器下的url，不能再转向到其他的web路径上。中间传递的是自己的容器内的request。
        - 重定向: 新的location可以重定向到任何URL上，实质是客户端发起了两次请求，也就没有request传递的概念。
- 转发的流程和原理？
    - 客户端发送http请求
    - web服务器接受此请求
    - 服务端在内部完成请求处理和转发动作
    - 将目标资源发送给客户端。
    - 对于客户端来说依然是第一次访问的路径，也就是客户端感觉不到服务端进行了转发。
    - 转发行为就是客户端只进行了一次访问请求。
- 重定向的流程是什么？
    - 客户端发送http请求
    - 服务端接受请求后发送302状态码响应及对应新的location给客户端
    - 客户端发现302状态码后会在发起一个新的http请求，请求的url是新的location地址
    - 新的location可以重定向到任何URL上
    - 客户端可以观察到地址的变换。




### 01.ARP（地址解析协议）
- 基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的。
- 当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个 **广播（ARP request）**，目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是（00-BB-00-62-C2-02）”。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。**ARP缓存表采用老化机制**，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。
- 当发送主机和目的主机不在同一个局域网中时，即便知道目的主机的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为ARP代理（ARP Proxy）。[博客](https://github.com/yangchong211/YCBlogs)



### 02.ICMP（互联网控制消息协议）
- 它 **用于TCP/IP网络中发送控制消息**，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。它与传输协议最大的不同：它一般不用于在两点间传输数据，而常常 **用于返回的错误信息或是分析路由**。
- ICMP控制的内容包括但不仅限于：echo响应（ping）、目标网络不可达、目标端口不可达、禁止访问的网络、拥塞控制、重定向、TTL超时...




### 03.路由选择协议
- 路由选择协议分为：静态的和动态的。Internet中使用的是动态路由选择协议，在Internet的概念中，将整个互联网划分为许多个小的**自治系统（AS）**。AS的最主要的特征：**一个AS对其他AS表现出的是一个单一 和一致的路由选择策略**。
- 由于AS的存在，路由选择协议又分为两种：
    - 内部网关协议（IGP）：即在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。比如：OSPF
    - 外部网关协议（EGP）：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。比如：BGP。




### 04.OSPF（开放式最短路径优先）
- OSPF属于内部网关协议（IGP）的一种，使用Dijkstra提出的**最短路径算法**。
- OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。其中，一个特别的区域被称为骨干区域（Backbone Area），该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。所有的内部路由都通过骨干区域传递到其他非骨干区域。所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过虚拟链路（Virtual-link）和骨干区域创建虚拟连接。[博客](https://github.com/yangchong211/YCBlogs)
- 划分区域的优点：
    - 将洪泛法的范围限制在一个区域中。
    - 减少每个区域内部路由信息交换的通信量。  
- OSPF使用的是**分布式链路状态协议**，使用 **洪泛法**向该路由器所有的相邻路由器发送信息。最终整个区域的所有路由器都得到一个这个信息的副本。这个副本就是 **链路状态数据库（LSDB）用来保存当前网络拓扑结构**，路由器上属于同一区域的链路状态数据库是相同的（属于多个区域的路由器会为每个区域维护一份链路状态数据库）。
- OSPF使用 **“代价（Cost）”**作为路由度量。
- 只有当链路发生变化时才会更新信息。如果同一个目的网络有多条路径，OSPF协议可以进行 **负载均衡**。



### 05.BGP（边界网关协议）
- 由于BGP是工作在AS之间的协议，并且各个AS的情况复杂，所以 **BGP只是力求找到一个可以到达目的网络且比较好的路由，而并不是寻找一条最佳路由**。每一个AS都应该有一个**“BGP发言人“**，一般来说，两个BGP发言人是通过一个共享网络连接在一起的，BGP发言人往往是**BGP边界路由**，但也可以不是。[博客](https://github.com/yangchong211/YCBlogs)
- 一个BGP发言人与其他AS的BGP发言人要交换路由信息，首先要建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话。当BGP发言人交换了路由信息后，就构造自治系统连通图，最后通过该图来进行路由选择。



### 06.DHCP（动态主机设置协议）
- DHCP是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：
    - 用于内部网络或网络服务供应商自动分配IP地址给用户
    - 用于内部网络管理员作为对所有电脑作中央管理的手段
- **动态主机设置协议（DHCP）是一种使网络管理员能够集中管理和自动分配IP网络地址的通信协议**。在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。
- DHCP使用了 **租约** 的概念，或称为计算机IP地址的有效期。租用时间是不定的，主要取决于用户在某地连接Internet需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期，DHCP能够在一个计算机比可用IP地址多的环境中动态地重新配置网络。DHCP支持为计算机分配静态地址，如需要永久性IP地址的Web服务器。



### 07.NAT（地址转换协议）
- NAT是一种 **在IP封包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术**。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。







### 03.Keep-Alive模式
- 什么是Keep-Alive模式
    - 我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
    - http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。
- 启用Keep-Alive的优点
    - 启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。
- 判断消息内容长度大小
    - Keep-Alive方式下如何判断消息内容/长度的大小？
        - Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可 以想象那效率是何等的低）！下面我介绍两种来判断方法。
    - 使用消息首部字段Conent-Length
        - Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……
    - 使用消息首部字段Transfer-Encoding
        - 当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用"Transfer-Encoding: chunked"这样的方式来代替Content-Length。
        - chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。





### 05.短连接与长连接
- 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。
- 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。
- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。



### 06.无连接和无状态
- 什么是无连接
    - 无连接并不是说不需要连接
        - Http协议只是一个应用层协议，最终还是要靠运输层的如TCP协议向上提供的服务进行连接。
    - 无连接的含义是：
        - **http约定了每次连接只处理一个请求，一次请求完成后就断开连接**，这样主要是为了缓解服务器的压力，减小连接对服务器资源的占用。我的理解是，建立连接实际上是运输层的事，面向应用层的http来说的话，它就是无连接的，因为上层对下层无感知。
- 什么是无状态
    - **无状态的指：**
        - HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。
    - **新请求新相应**
        - 使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。
        - 也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。
        - 也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。
    - **后来出现的弊端**
        - 随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。
    - **Cookie解决无状态困境**
        - 每个请求之间都是独立的，对于之前的请求事务没有记忆的能力。所以就出现了像Cookie这种，用来保存一些状态的东西。
        - Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。












