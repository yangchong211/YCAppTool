#### 目录介绍
- 01.快速了解线程
    - 1.1 线程的简单介绍
    - 1.2 多线程有何意义
    - 1.3 Java程序是多线程
    - 1.4 Java中的主线程
- 02.快速了解进程
    - 2.1 什么是进程
    - 2.2 多进程的意义
    - 2.3 进程状态有哪些
    - 2.4 进程状态转换
    - 2.5 进程通信
    - 2.6 进程同步
    - 2.7 用户态和核心态
    - 2.8 进程死锁



### 01.快速了解线程
#### 1.1 线程的简单介绍
- 线程（英语：thread）是操作系统能够进行运算调度的最小单位。
    - 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
    - 在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。
    - 一个进程可以有很多线程，每条线程并行执行不同的任务。线程是程序使用CPU的基本单位。注意：线程是依赖于进程存在的。
- 同进程不同线程资源共享
    - 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。
    - 但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。


#### 1.2 多线程有何意义
- 为何要多线程
    - 在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。
    - 在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。
- 多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。
    - 那么怎么理解这个问题呢?我们程序在运行的使用,都是在抢CPU的时间片(执行权),如果是多线程的程序,那么在抢到CPU的执行权的概率应该比较单线程程序抢到的概率要大。
    - 那么也就是说,CPU在多线程程序中执行的时间要比单线程多,所以就提高了程序的使用率.但是即使是多线程程序,那么他们中的哪个线程能抢占到CPU的资源呢，这个是不确定的,所以多线程具有随机性.
- 并行和并发
    - 前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
    - 后者是物理上同时发生，指在某一个时间点同时运行多个程序。


#### 1.3 Java程序是多线程
- 一个java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上java程序天生就是一个多线程程序，包含了：
    - （1）分发处理发送给给JVM信号的线程；
    - （2）调用对象的finalize方法的线程；
    - （3）清除Reference的线程；
    - （4）main线程，用户程序的入口。
- Java程序运行原理
    - Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。
    - 该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。
- JVM的启动是多线程的吗
    - JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。


#### 1.4 Java中的主线程
- 当Java程序启动时，会立即开始运行一个线程，因为它是程序开始时执行的线程，所以这个线程通常称为程序的主线程。其他子线程都是从主线程产生的。
    - 可以通过调用 currentThread() 方法获得对主线程的一个引用，该方法是Thread类的共有静态成员，返回对调用它的线程的引用，方法原型如下所示：
    ```
    public static native Thread currentThread();
    ```
- 例如，运行以下Demo
    ```
    public class Demo {
    
    	public static void main(String[] args) {
    		Thread t=Thread.currentThread();
    		System.out.println("Thread:"+t);
    		System.out.println("Thread Name:"+t.getName());
    		
    		t.setName("MyName");
    		System.out.println("Thread:"+t);
    		System.out.println("Thread Name:"+t.getName());
    	}
    	
    }
    ```
    - 输出值为：
    ```
    Thread:Thread[main,5,main]
    Thread Name:main
    Thread:Thread[MyName,5,main]
    Thread Name:MyName
    ```
    - 当将线程 t 直接作为println() 方法的参数输出时，将依次显示线程的名称、优先级以及线程所属线程组的名称。
    - 默认情况下，主线程的名称是 main，优先级是5，主线程所属线程组的名称也是 main。线程组是将一类线程作为整体来控制状态的数据结构。可以通过 Thread.setName(String) 方法来设置线程名称。




### 02.快速了解进程
#### 2.1 什么是进程
- 什么是进程呢？
    - 通过任务管理器我们就可以看到进程的存在。
- 概念：
    - 进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。

#### 2.2 多进程的意义
- 单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。
- 对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗？不是。[博客](https://github.com/yangchong211/YCBlogs)
- 因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，
- 所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。多进程的作用不是提高执行速度，而是提高CPU的使用率。


#### 2.3 进程状态有哪些
- 进程状态有哪些
    - 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
    - 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
    - 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。
- 进程状态图
    - 01.1图
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-9f1105d5a3b927ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 2.4 进程状态转换
- **注意区别就绪状态和等待状态：**
    - 就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。
- **就绪状态 -> 运行状态：**
    - 处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。
- **运行状态 -> 就绪状态：**
    - 处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。
- **运行状态 -> 阻塞状态：**
    - 当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。
- **阻塞状态 -> 就绪状态：**
    - 当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。



#### 2.5 进程通信
- 进程通信是指进程之间的信息交换。
    - PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。
- **共享存储**
    - 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。
    - 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。
- **消息传递**
    - 在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。
    - 1) 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。[博客](https://github.com/yangchong211/YCBlogs)
    - 2) 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。
- **管道通信**
    - 管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。


#### 2.6 进程同步
- 多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。
    - 进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性
- 同步机制需要遵循的原则：
    - 1.空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请
    - 2.忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问
    - 3.有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等
    - 4.让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等
- 经典的进程同步问题：
    - 生产者-消费者问题；哲学家进餐问题；读者-写者问题
- 同步的解决方案：
    - 管程，信号量。


#### 2.7 用户态和核心态
- ![img](http://upload-images.jianshu.io/upload_images/3985563-d36d6d7917326e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **当程序运行在3级特权级上时，就可以称之为运行在用户态**，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，**当程序运行在级特权级上时，就可以称之为运行在内核态。**
- 虽然用户态下和内核态下工作的程序有很多差别，**但最重要的差别就在于特权级的不同，即权力的不同。** 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。
- 当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。[博客](https://github.com/yangchong211/YCBlogs)
- **用户态切换到内核态的3种方式**
    - 1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
    - 2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
    - 3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。


#### 2.8 进程死锁
- 死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。
- **死锁原因：**
    - 1.竞争资源：请求同一有限资源的进程数多于可用资源数
    - 2.进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链
- **死锁产生的必要条件：**
    - 1.互斥条件:进程对所分配的资源进行排他性的使用
    - 2.请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源
    - 3.不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺
    - 4.环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链
- **死锁处理：**
    - 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量
    - 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法
    - 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大
    - 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大   


### 03.线程和进程的关系
- 进程与线程概念区别
    - **进程：** 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。
    - **线程：** 是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。
- 进程与线程调度区别
    - 调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销。
- 进程与线程并发行区别
    - 并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。[博客](https://github.com/yangchong211/YCBlogs)
- 进程与线程拥有资源对比
    - 进程，拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd）
    - 线程，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。
- 进程与线程系统开销对比
    - 系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。
    - 而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。



