### 目录结构
- 注意：红色字体为未答出的知识点
- 0.Java语言概述
- 1.Java标识符规则【规则，注意事项，命名规范】
- 2.常量和变量【区别，常量种类】
- 3.进制【种类，转换，补码反码】
- 5.字符编码【种类】
- 6.运算符【种类，区别】
- 7.Java基本语句结构【种类，区别说明】
- 8.方法【定义，格式】
- 9.数组【一维数组，二维数组】
- 10.内存分配以及栈和堆的
- 11.使用switch和if-else区别



#### 1.0.2.0 instanceof它的作用是什么？在使用过程中注意事项有哪些？它底层原理是如何实现的，说说你的理解？
- 它的作用是什么？
    - instanceof是Java的一个二元操作符，和==，>，<是同一类东西。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。
- 使用过程中注意事项有哪些？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 类的实例包含本身的实例，以及所有直接或间接子类的实例
    - instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误
    ```
    //比如下面就会编译错误
    String s = null;
    s instanceof null
    s instanceof Integer
    ```



### 1.常见的关键字
- 如果还有没有写上的，麻烦小伙伴告知一声……
    ```
    用于定义数据类型的关键字
    class interface    byte short int long float double char boolean void               
    用于定义数据类型值的关键字
    true false null       
    用于定义流程控制的关键字
    if    else switch    case default while do for break    continue return           
    用于定义访问权限修饰符的关键字
    private    protected public       
    用于定义类，函数，变量修饰符的关键字
    abstract final static synchronized   
    用于定义类与类之间关系的关键字
    extends    implements           
    用于定义建立实例及引用实例，判断实例的关键字
    new    this super instanceof   
    用于异常处理的关键字
    try    catch finally throw    throws
    用于包的关键字
    package    import           
    其他修饰符关键字
    native strictfp transient volatile assert
    ```



#### 1.0.1.1 Object有哪些公有方法？Object类toString()返回的是什么？为什么说类一定要实现Cloneable接口才可以克隆？
- 常用方法
    - equals()： 和==作用相似[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - hashCode()：用于哈希查找，重写了equals()一般都要重写该方法
    - getClass()： 获取Class对象
    - wait()：让当前线程进入等待状态，并释放它所持有的锁
    - notify()&notifyAll()： 唤醒一个（所有）正处于等待状态的线程
    - toString()：转换成字符串
- Android的Object类toString()返回的是什么？
    - 返回的是类名和hashcode的组合字符串
    ```
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
    ```
- 为什么说类一定要实现Cloneable接口才可以克隆？具体看下Android中Object类代码
    - 看一下代码即可知道，对象需要instanceof判断该对象是否是Cloneable的实例
    ```
    protected Object clone() throws CloneNotSupportedException {
        if (!(this instanceof Cloneable)) {
            throw new CloneNotSupportedException("Class " + getClass().getName() +
                                                 " doesn't implement Cloneable");
        }
    
        return internalClone();
    }
    ```




#### 0.Java语言概述
- **0.1 jdk工具部分exe解释**
    * jar.exe       jar包
    * javadoc.exe   文档生成器
    * Java.exe      解释器
    * Javac.exe     编辑器
- **0.2 开发与运行Java程序需经过哪些过程？**
    * 用工具编辑源程序，也就是写代码，保存
    * 用Java编辑器工具javac.exe编译源程序文件，生成字节码.class文件
    * 用Java解释器工具Java.exe解释运行生成.class文件
- **0.3 Java是如何实现跨平台的？**
    * 如下所示：
    - 跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。
    - JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。
    - 而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
    - JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
    - 注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。
    - 所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。
    - 注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。



#### 1.Java标识符规则
- **1.1 组成规则**
	* 英文大小写字母
	* 数字字符
	* $或_
- **1.2 注意事项**
	* 不能以数字开头
	* 不能是Java中的关键字
	* 区分大小写
	* 不能有空格
- **1.3 命名规范【必须见名知意】**
	* 下划线式命名：my_name
	* 驼峰式命名：myName
	* 类，接口命名：必须是大写字母开头，比如PersonActivity
	* 方法，变量【字符串】命名：getData()，otherName
	* 常量命名：一般全是大写，比如MAX_VALUE


#### 2.常量和变量
- **2.1 什么是常量和变量**
	* 其值不可以改变的称之为常量
	* 其值会发生变化的称之为变量
- **2.2 常量有哪些**
	* 字符串常量     用双引号包括的     "hello world"
	* 整型常量         所有的整数     199
	* 小数常量         所有的小数     4.50
	* 字符常量         用单引号包括的     'a'
	* 布尔常量         true和false    
	* 空常量            null
- **2.3 变量**
	* 用来描述值可以变化的量，比如室外温度，App活跃用户量等



#### 3.进制
- **3.1 进制有哪些**
- 二进制
	* 0和1     前缀0B或者0b       比如：0B1001      转为十进制是9
- 八进制
	* 0-7       前缀0       比如：0103       
- 十进制【我们常用的】
	* 0-9       没有前缀
- 十六进制
	* 0-9 和 A-F     前缀0x或者0X          比如：0x123
- 进制转化
	* 任何进制转化为十进制公式：系数 * 底数 ^ 指数

```
0b1010 = 1 * 2^3 + 0 *2^2 + 1*2^1 + 0*2^0
       = 8 + 0 + 2 + 0
       = 10

0123  = 1*8^2 + 2*8^1 + 3*8^0
      = 64 + 16 + 3
      = 83

0x123 = 1*16^2 + 2*16^1 + 3*16^0
      = 256 + 32 + 3
      = 291
```

- **3.2 补码**
	* 正数的补码和原码相同

```
5
原码：0000 0101
补码：0000 0101
	* 负数的补码是它的反码加1

-5：
原码：1000 0101
反码：1111 1010
    +         1
------------------
补码  1111 1011
```




#### 5.字符编码
- 常见的字符编码
	* ASCII码
	* GBK码
	* Unicode码【占2个字节】


#### 6.运算符
- **6.1 运算符有哪些？**
	* 算术运算符
	* 赋值运算符
	* 关系运算符
	* 逻辑运算符
	* 三目运算符
	* 特殊运算符：位运算符
- **6.2 算术运算符**
	* + ，- ， * ， / ， %【取余】 ， ++【自加】， --【自减】
- **6.3 赋值运算符**
	* = ， += ， -= ， *= ， /= ， %= 
- **6.4 关系运算符**
	* == ， > , < , >= , <= , !=
- **6.5 逻辑运算符**
	* & ，^ ，| ，&& ，|| ，！ ， ^
- **6.6 三目运算符【Android中用的很多】**
	*  a == b ？ c ： d
	* 格式：(条件表达式)？表达式1：表达式2
- **6.7 位运算符**
	* & , |   ,  ^ ,  ~  ,  <<  ,  >>  ,  >>>
    - 移位操作符操作的运算对象也是二进制的“位”。
        - 移位操作符只可用来处理整数类型，左移位操作符（<<）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0），“有符号”右移位操作符（>>）则按照操作符右侧指定的位数将操作符左边的操作数向右移。“有符号”右移位操作符使用“符号扩展”；若符号位正，则在高位插入0；若符号位负。则在高位插入1。java中增加了一种“无符号”右移位操作符（>>>）,他使用“零扩展”；无论正负，都在高位插入0。这一操作符是C或C++中所没有的。
        - 5<<2 等于20
            - 5的二进制是 0000 0000 0000 0101
            - 左移两位    0000 0000 0001 0100
        - 5>>2 等于 1
            - 5的二进制是 0000 0000 0000 0101
            - 右移两位 0000 0000 0000 0001
        - -5>>2 等于 -2
            - -5的二进制是 1111 1111 1111 1011
            - 右移两位  1111 1111 1111 1110 转十进制，例5反着来，先-1，然后取反
    - 其他类型位运算符
        - 如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转为int类型，并且得到结果也是一个int类型的值，只有数值右端的底5位才有用，这样可防止我们移位超过int类型所具有的位数，（因为2的5次方位为32，而int类型只有32位）。若对一个long类型的数值进行处理，最后得到结果也是long类型，此时只会用到数值右端的底6位，以防止移位超过long类型数值具有的位数。
        - “移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋值给左边的变量。但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题，如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果。他们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。


#### 7.Java基本语句结构
- **7.1 语句结构种类**
	* 顺序结构
	* 选择结构
	* 循环结构
- **7.2 顺序结构**
	* 从上到下依次执行
- **7.3 选择结构【可以嵌套】**
	* if  ，  if  else  ， if  else if …… else
	* switch case【支持byte，short，char，int，String】
- **7.4 循环结构**
- for
    ```
    for(初始化语句;判断条件语句;控制条件语句) {
             循环体语句;
    }
    第一步：先执行初始化语句，只执行一次
    第二步：执行判断条件语句
    第三部：执行循环体语句
    第四步：执行控制条件语句，然后再执行循环体语句【循环】
    ```
- while
    ```
    初始化语句;
    while(判断条件语句) {
        循环体语句;
        控制条件语句;
    }
    ```

- do while
    ```
    do {
             循环体语句;
    }while((判断条件语句);
    ```


#### 8.Java方法
- **8.1 定义**
- 方法就是完成特定功能的代码块
	* 1：系统方法，只需要会使用，不需要知道内部的结构
	* 2：自定义方法：方法的内部实现需要我们来写
	* 3：方法内部不能再嵌套方法
- **8.2 格式**
- 方法格式
    ```
    修饰符   返回值类型   方法名(参数类型 参数 , ……){
         函数体
         return 返回值
    }
    ```
- 修饰符: public static或直接是public或是其它private
- 返回类型:所有的数据类型（基本类型：int ,char ,float, long, 引用类型:String）
- 方法名：1:见名知意 2: getMax
- 参数类型:所有的数据类型 ，如果一个方法没有返回值，则返回值类型为void
- 参数名:变量名
- 返回值：就是要返回的结果（这个结果必须和返回类型一致）




#### 11.使用switch和if-else区别
- **11.1 switch语句特点**
    - 使用switch语句时，要注意表达式必须是符合byte，char，short，int或枚举类型的表达式，而不能使用浮点类型或long类型。
    - switch语句将表达式的值依次与每个case子语句中的常量值相比较。如果匹配成功，则执行该case语句中的语句，直到遇到break语句为止。
    - default语句是可选的，当表达式的值与任何一个case语句都不匹配时，就执行default后的语句。



- **11.2 switch语句与if-else比较**
    - if-else只是单纯地一个接一个比较；if...else每个条件都计算一遍；
    - 使用了Binary，Tree算法；绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true。编译器编译switch与编译if...else...不同。不管有多少case，都直接跳转，不需逐个比较查询；switch只计算一次值，然后都是test , jmp……有很多else if的时候，用switch case比较清晰
    - switch...case与if...else，if的根本区别在于，switch...case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch...case不用像if...else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。



### 01.Java和C++在运行方式上区别
- Java 代码有很多种不同的运行方式，比如在开发工具中运行、双击执行 jar 文件运行、在命令行中运行，甚至可以在网页中运行。
- Java 的运行离不开 JRE（Java 运行时环境）， JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。当然我们程序员更经常接触到的是 JDK（Java 开发工具包），包含了JRE，并且还附带了一系列开发、诊断工具。
- 运行 C++ 代码则无需额外的运行时，往往把代码直接编译成 CPU 所能理解的机器码即可。



### 02.为什么Java要在虚拟机里运行
- Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。
- 所以可以在 Java 代码与机器码之间加一层虚拟机，先将 Java 代码转换成 Java 字节码，最后才转换成机器码，降低复杂度。
- Java Hello World 字节码格式
    ``` java
    # 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码
    0x00:  b2 00 02         getstatic java.lang.System.out
    0x03:  12 03            ldc "Hello, World!"
    0x05:  b6 00 04         invokevirtual java.io.PrintStream.println
    0x08:  b1               return
    ```


### 03.Java虚拟机的好处
- 通过为各个平台（Linux、Windows、Mac os等）提供Java虚拟机的软件实现，在各个平台上都可以将Java代码转换成字节码来运行Java（可移植性），达到 “一次编写、到处运行” 的目的
- Java虚拟机为我们带来了一个托管环境（Managed Runtime），可以替我们处理一些冗长而且容易出错的代码，最重要的譬如自动内存管理与垃圾回收，同时还提供诸如数组越界、动态类型、安全权限等的动态检测，让我们可以专心的写业务代码



### 04.如何运行Java字节码
- 首先从虚拟机的角度来看：
    - 首先将 Java 代码编译成的 class 文件
    - 将 class 文件加载到 Java 虚拟机中（载入Java内存），加载后的 Java 类会被存放于方法区（Method Area）中
    - 运行时，虚拟机执行方法区内的代码
    - ![image](http://image.laijianfeng.org/20181105_234946.png)
- Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的PC寄存器。
    - 本地方法，用关键字 native 修饰，基于JNI（Java Native Interface，Java本地接口），它允许 Java 代码和其他语言写的代码进行交互
- 在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成
一个栈帧，用以存放局部变量以及字节码的操作数。（栈帧是提前计算好且不需连续分布）
- 当退出当前执行的方法时，不管是正常返回还是异常返回，Java虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。
- Java 虚拟机将字节码翻译成机器码有两种形式：
    - 解释执行：即逐条将字节码翻译成机器码并执行；
    - 即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。
    - ![image](http://image.laijianfeng.org/20181105_235641.png)
- 解释执行的好处是无须等待编译，即时编译的好处是实际执行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点，它会先解释执行字节码，然后将其中反复执行的热点代码，以方法为单位进行即时编译。


### 05.关于即时编译提高性能
- 即时编译主要是为了提高 Java 虚拟机的启动性能以及峰值性能，它建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。
- 对于百分之八十（大部分）不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；对于百分之二十（小部分）的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。
- 为了满足不同用户场景的需要（在编译时间和生成代码的执行效率之间进行取舍），HotSpot 内置了多个即时编译器：C1、C2 和 Graal
    - C1，又叫 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，编译时间较短。
    - C2，又叫 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，编译时间较长，但同时生成代码的执行效率较高。
    - Graal 是Java 10 正式引入的实验性即时编译器
- 从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。





### 其他介绍



