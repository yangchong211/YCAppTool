#### 目录介绍
- 00.锁的分类有哪些
- 01.公平锁/非公平锁
    - 1.1 公平锁
    - 1.2 非公平锁
    - 1.3 公平锁VS非公平锁
- 02.乐观锁/悲观锁
    - 2.1 乐观锁
    - 2.2 悲观锁
    - 2.3 两者对比
- 03.可重入锁
    - 3.1 什么是可重入锁
    - 3.2 使用场景
- 04.独享锁/共享锁
- 05.互斥锁/读写锁
- 06.分段锁
- 07.偏向锁/轻量级锁/重量级锁
- 08.什么是可中断锁
- 09.自旋锁




### 00.锁的分类有哪些
- 大致的分类有这些
    - 公平锁/非公平锁
    - 乐观锁/悲观锁
    - 可重入锁
    - 独享锁/共享锁
    - 互斥锁/读写锁
    - 分段锁
    - 偏向锁/轻量级锁/重量级锁
    - 可中断锁
    - 自旋锁




### 01.公平锁/非公平锁
#### 1.1 公平锁
- 一句话概括
    - 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。
- 为何需要公平锁
    - CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程**先到先得**的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。
    - 那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程**按照时间的先后顺序**执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。
- ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。以下是使用公平锁实现的效果：
    ```
    public class LockFairTest implements Runnable{
        //创建公平锁
        private static ReentrantLock lock=new ReentrantLock(true);
        public void run() {
            while(true){
                lock.lock();
                try{
                    System.out.println(Thread.currentThread().getName()+"获得锁");
                }finally{
                    lock.unlock();
                }
            }
        }
    }
    ```



#### 1.2 非公平锁
- 一句话概括
    - 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。
- 非公平锁有哪些
    - 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。


#### 1.3 公平锁VS非公平锁
- 1.公平锁每次获取到锁为同步队列中的第一个节点，**保证请求资源时间上的绝对顺序**，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，**造成“饥饿”现象**。
- 2.公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，**保证了系统更大的吞吐量**。


### 02.乐观锁/悲观锁
- 乐观锁与悲观锁不是指具体的什么类型的锁
    - 它们是指看待并发同步的角度。
- 悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
    - 悲观锁在Java中的使用，就是利用各种锁。
    - 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。


#### 2.1 乐观锁
- 一句话概括
    - 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在操作共享数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
    - 实际上，当多个线程同时操作一个共享资源时，只有一个线程会成功，那么失败的线程呢？它们不会像悲观锁一样在操作系统中挂起，而仅仅允许失败的线程重试，也允许自动放弃退出操作。
- 乐观锁有哪些
    - CAS，比如AtomicInteger
    

#### 2.2 悲观锁
- 一句话概括
    - 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 悲观锁有哪些
    - synchronized，Lock锁等


#### 2.3 两者对比
- 乐观锁相比悲观锁来说
    - 不会带来死锁、饥饿等活性故障问题，线程间的相互影响也远远比悲观锁要小。更为重要的是，乐观锁没有因竞争造成的系统开销，所以在性能上也是更胜一筹。
- 悲观锁相比乐观锁来说
    - 虽然乐观锁在并发性能上要比悲观锁优越，但是在写大于读的操作场景下，CAS 失败的可能性会增大，如果不放弃此次 CAS 操作，就需要循环做 CAS 重试，这无疑会长时间地占用 CPU。
    - 它只能保证单个变量操作的原子性，当涉及到多个变量时，CAS 就无能为力了，但悲观锁可以通过对整个代码块加锁来做到这点。



### 03.可重入锁
#### 3.1 什么是可重入锁
- 一句话概括
    - 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- 举个例子加深理解
    - 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
    - 对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
    ```
    synchronized void setA() throws Exception{
        Thread.sleep(1000);
        setB();
    }
    
    synchronized void setB() throws Exception{
        Thread.sleep(1000);
    }
    ```
    - 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。


#### 3.2 使用场景




### 04.独享锁/共享锁
#### 4.1 什么是独享锁
- 一句话概括
    - 独享锁是指该锁一次只能被一个线程所持有。
- 独享锁有哪些
    - 对于Java ReentrantLock而言，其是独享锁。
    - 对于Synchronized而言，当然是独享锁。



#### 4.2 什么是共享锁
- 一句话概括
    - 共享锁是指该锁可被多个线程所持有。
- 共享锁有哪些
    - 对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
    - 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
- 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。


### 05.互斥锁/读写锁
- 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。


#### 5.1 什么是互斥锁




#### 5.2 什么是读写锁
- 一句话概括
    - 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
- 为何需要读写锁
    - 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。
- 读写锁有哪些
    - ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。


### 06.分段锁
- 一句话概括
    - 分段锁其实是一种锁的设计，并不是具体的一种锁，
- 举个例子
    - 对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
    - 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
    - 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
    - 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
- 分段锁的设计目的
    - 主要是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。



### 07.偏向锁/轻量级锁/重量级锁
- 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。





### 08.什么是可中断锁
- 一句话概括
    - 就是可以响应中断的锁
- 有哪些中断锁
    - 在Java中，**synchronized就不是可中断锁，而Lock是可中断锁**。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。`lockInterruptibly()`的用法体现了Lock的可中断性。


### 09.自旋锁
- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。





### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e










