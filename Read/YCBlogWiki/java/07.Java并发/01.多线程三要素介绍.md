#### 目录介绍
- 01.线程安全特性
    - 1.1 什么是线程安全
    - 1.2 线程安全级别
    - 1.3 线程安全必备
- 02.多线程三要素
    - 2.1 三要素分别是啥
    - 2.2 如何理解原子性
    - 2.3 如何理解可见性
    - 2.4 如何理解有序性
    - 2.5 三要素作用
- 03.处理多线程并发
    - 3.0 如何处理并发
    - 3.1 保证原子性
    - 3.2 保证可见性
    - 3.3 保证有序性
    - 3.4 回答一个问题
- 04.java并发分析
    - 4.1 为什么要用到并发
    - 4.2 并发编程有哪些缺点
    - 4.3 应该了解的概念




### 01.线程安全特性
#### 1.1 什么是线程安全
- 什么是线程安全
    - 线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
    - 通俗来讲，如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的，或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题 。
- 并发切入点是什么？
    - 并发分析的切入点分为**两个核心，三大性质**。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性。





#### 1.2 线程安全级别
- 线程安全也是有几个级别
    - 不可变：
        - 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
    - 绝对线程安全
        - 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
    - 相对线程安全
        - 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。
    - 线程非安全[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - ArrayList、LinkedList、HashMap等都是线程非安全的类.




### 1.3 线程安全必备
- 线程安全需要保证几个基本特性
    - 1、原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
    - 2、可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
    - 3、有序性，是保证线程内串行语义，避免指令重排等。



### 02.多线程三要素
#### 2.1 三要素分别是啥
- 三要素分别是：原子性，可见性，有序性



#### 2.2 如何理解原子性
- 如何理解原子性
    - 即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
- 举一个例子
    - 关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。




#### 2.3 如何理解可见性
- 如何理解可见性
    - 当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。
- 举一个例子
    - CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。




#### 2.4 如何理解有序性
- 如何理解有序性
    - 顺序性指的是，程序执行的顺序按照代码的先后顺序执行。
- 举一个例子
    - 语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。




#### 2.5 三要素作用
- 上面这三个要素主要作用是保障线程安全。保证线程安全可从多线程三特性出发：
    - 原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行
        - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
        - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
    - 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
        - volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
        - synchronized：在释放锁之前会将工作内存新值更新到主存中
    - 有序性（Ordering）：程序代码按照指令顺序执行
        - volatile： 本身就包含了禁止指令重排序的语义
        - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入



### 03.处理多线程并发
#### 3.0 如何处理并发
- 保证原子性
    - 锁和同步：lock锁 或者 synchronized同步
    - CAS
- 保证可见性
    - volatile：比如单利对象用volatile修饰
- 保证有序性
    - synchronized和锁保证顺序性


#### 3.1 保证原子性
- 原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。我们先来看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：
    ``` java
    > int a = 10;  //1
    > a++;  //2
    > int b=a; //3
    > a = a+1; //4
    ```
- 上面这四个语句中只**有第1个语句是原子操作**，将10赋值给线程工作内存的变量a,而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3,4的分析同理可得这两条语句不具备原子性。当然，java内存模型中定义了8中操作都是原子的，不可再分的。
    - 1. lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；
    - 2. unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
    - 3. read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；
    - 4. load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本
    - 5. use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
    - 6. assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；
    - 7. store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；
    - 8. write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
- 上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。
    - 那么如何理解这些指令了?比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：**java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的**。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：**read a,read b, load b,load a**。
- 由原子性变量操作read,load,use,assign,store,write，可以**大致认为基本数据类型的访问读写具备原子性**（例外就是long和double的非原子性协定）
- synchronized
    - 上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下lock和unlock两条原子操作。如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是---synchronized关键字，也就是说**synchronized满足原子性**。
- volatile
    - 我们先来看这样一个例子：
    ```java
    public class VolatileExample {
        private static volatile int counter = 0;
    
        public static void main(String[] args) {
            for (int i = 0; i < 10; i++) {
                Thread thread = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 10000; i++)
                            counter++;
                    }
                });
                thread.start();
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(counter);
        }
    }
    ```
    - 开启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000;可是运行多次都是小于100000的结果，问题在于 **volatile并不能保证原子性**，在前面说过counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。
- 如果让volatile保证原子性，必须符合以下两条规则：
    - 1. **运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；**
    - 2. **变量不需要与其他的状态变量共同参与不变约束**




#### 3.2 保证可见性
- 可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。
    - 通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，**synchronized具有可见性**。
    - 同样的在volatile分析中，会通过在指令中添加**lock指令**，以实现内存可见性。因此, **volatile具有可见性**



#### 3.3 保证有序性
- synchronized
    - synchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此**synchronized具有有序性**。
- volatile
    - 在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的**。在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：
    ```java
    public class Singleton {
        private Singleton() { }
        private volatile static Singleton instance;
        public Singleton getInstance(){
            if(instance==null){
                synchronized (Singleton.class){
                    if(instance==null){
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
    ```
- 这里为什么要加volatile了？我们先来分析一下不加volatile的情况，有问题的语句是这条：
    - instance = new Singleton();
    - 这条语句实际上包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序：
    - ![image](http://upload-images.jianshu.io/upload_images/2615789-e7931260b0449eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得。而**用volatile修饰**的话就可以禁止2和3操作重排序，从而避免这种情况。**volatile包含禁止指令重排序的语义，其具有有序性**。




### 04.java并发分析
#### 4.1 为什么要用到并发
- 一直以来，硬件的发展极其迅速，也有一个很著名的"摩尔定律"，可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展，这其中的关系应该是多核CPU的发展为并发编程提供的硬件基础。
    - 摩尔定律并不是一种自然法则或者是物理定律，它只是基于认为观测数据后，对未来的一种预测。按照所预测的速度，我们的计算能力会按照指数级别的速度增长，不久以后会拥有超强的计算能力，正是在畅想未来的时候，2004年，Intel宣布4GHz芯片的计划推迟到2005年，然后在2004年秋季，Intel宣布彻底取消4GHz的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核CPU。短短十几年的时间，家用型CPU,比如Intel i7就可以达到4核心甚至8核心。而专业服务器则通常可以达到几个独立的CPU，每一个CPU甚至拥有多达8个以上的内核。因此，摩尔定律似乎在CPU核心扩展上继续得到体验。
- 因此，多核的CPU的背景下，催生了并发编程的趋势
    - 通过**并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升**。
- 顶级计算机科学家Donald Ervin Knuth如此评价这种情况：
    - 在我看来，这种现象（并发）或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。
- 另外，在特殊的业务场景下先天的就适合于并发编程。
    - 比如在图像处理领域，一张1024X768像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。
- **面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分** 。正是因为这些优点，使得多线程技术能够得到重视，也是一名CS学习者应该掌握的：
    - 充分利用多核CPU的计算能力；
    - 方便进行业务拆分，提升应用性能


#### 4.2 并发编程有哪些缺点
- 多线程技术有这么多的好处，难道就没有一点缺点么，就在任何场景下就一定适用么？很显然不是。


##### 4.2.1 频繁的上下文切换
- 时间片是CPU分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能，过于频繁反而无法发挥出多线程编程的优势。
- 通常减少上下文切换可以采用无锁并发编程，CAS算法，使用最少的线程和使用协程。
    - 无锁并发编程：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
    - CAS算法，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换
    - 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
    - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
- 由于上下文切换也是个相对比较耗时的操作，所以在"java并发编程的艺术"一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用**Lmbench3测量上下文切换的时长**  **vmstat测量上下文切换次数**



##### 4.2.2 线程安全
- 多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。
    ```java
    public class DeadLockDemo {
        private static String resource_a = "A";
        private static String resource_b = "B";
    
        public static void main(String[] args) {
            deadLock();
        }
    
        public static void deadLock() {
            Thread threadA = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (resource_a) {
                        System.out.println("get resource a");
                        try {
                            Thread.sleep(3000);
                            synchronized (resource_b) {
                                System.out.println("get resource b");
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            });
            Thread threadB = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (resource_b) {
                        System.out.println("get resource b");
                        synchronized (resource_a) {
                            System.out.println("get resource a");
                        }
                    }
                }
            });
            threadA.start();
            threadB.start();
    
        }
    }
    ```
- 在上面的这个demo中，开启了两个线程threadA, threadB,其中threadA占用了resource_a, 并等待被threadB释放的resource _b。threadB占用了resource _b正在等待被threadA释放的resource _a。因此threadA,threadB出现线程安全的问题，形成死锁。同样可以通过jps,jstack证明这种推论：
    ``` java
    "Thread-1":
      waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.String),
      which is held by "Thread-0"
    "Thread-0":
      waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.String),
      which is held by "Thread-1"
    
    Java stack information for the threads listed above:
    ===================================================
    "Thread-1":
            at learn.DeadLockDemo$2.run(DeadLockDemo.java:34)
            - waiting to lock <0x00000007d5ff53a8(a java.lang.String)
            - locked <0x00000007d5ff53d8(a java.lang.String)
            at java.lang.Thread.run(Thread.java:722)
    "Thread-0":
            at learn.DeadLockDemo$1.run(DeadLockDemo.java:20)
            - waiting to lock <0x00000007d5ff53d8(a java.lang.String)
            - locked <0x00000007d5ff53a8(a java.lang.String)
            at java.lang.Thread.run(Thread.java:722)
    
    Found 1 deadlock.
    ```
- 如上所述，完全可以看出当前死锁的情况。那么，通常可以用如下方式避免死锁的情况：
    - 1.避免一个线程同时获得多个锁；
    - 2.避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；
    - 3.尝试使用定时锁，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；
    - 4.对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
- 所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，DCL等这些问题（在后续篇幅会讲述）。而在学习多线程编程技术的过程中也会让你收获颇丰。



#### 4.3 应该了解的概念
##### 4.3.1 同步VS异步
- 同步和异步通常用来形容一次方法调用。
    - 同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。
    - 而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。
- 举个例子
    - 比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。
    - 而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。



##### 4.3.2 并发与并行
- 并发和并行是十分容易混淆的概念。
    - 并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。
- 实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。



##### 4.3.3 阻塞和非阻塞
- 阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。



##### 4.3.4 临界区
- 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。






### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e




