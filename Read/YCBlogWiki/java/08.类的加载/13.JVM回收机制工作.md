#### 目录介绍
- 01.检测垃圾算法有哪些
- 02.引用计数法分析
    - 2.1 什么是引用计数法
    - 2.2 引用计数的优缺点
- 03.可达性分析算法分析
    - 3.1 什么是可达性分析算法
    - 3.2 可达性分析算法思路
    - 3.3 标记可达对象
- 04.垃圾回收方式思考
- 06.标记垃圾的算法
    - 6.1 处理垃圾的算法有哪些
    - 6.2 标记-清除（Mark-sweep）
    - 6.3 复制（Copying）
- 07.分代收集算法分析
    - 7.1 分代收集算法了解
    - 7.2 如何对对象划分
    - 7.3 年轻代对象说明
    - 7.4 年老代对象说明
    - 7.5 分代收集器类型




### 01.检测垃圾算法有哪些
- 垃圾收集器一般必须完成两件事：
    - 检测出垃圾；回收垃圾。
- 怎么检测出垃圾？
    - 一般有以下几种方法：引用计数法，可达性分析算法。
- 注意有时候通常将可达性分析算法称为根搜索算法。




### 02.引用计数法分析
#### 2.1 什么是引用计数法
- 给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。
    - 好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收。
    - 引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。
- 如果使用引用计数器，那种场景+1，那种场景-1
    - 下面这种场景，引用计数器最终是多少？
    ``` java
    public class Test {
        Object instance = null;
        public static void main(String[] args) {
            List<Test> list =new ArrayList();
            Test objA = new Test();
            list.add(objA);
            list.add(objA);
            list.remove(objA);
            objA.instance = list.get(0);
            objA = null;
        }
    }
    ```



#### 2.2 引用计数的优缺点
- 引用计数的优点：
    - 垃圾收集器可以很快地执行，当一个对象的引用数为0时就可以回收这个对象，垃圾收集交织在程序的正常执行过程中，不用长时间中断程序的正常执行。
- 引用计数的缺点：
    - 1.每次引用计数的增加和减少会带来额外的开销；2.无法检测出循环引用。
- 总结一下：
    - 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。




### 03.可达性分析算法分析
#### 3.1 什么是可达性分析算法
- 可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常量池中引用的对象，本地方法中引用的对象等。
- 什么是根集：所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。



#### 3.2 可达性分析算法思路
- 这种算法的基本思路：
- （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。
- （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。
- （3）重复（2）。
- （4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。




#### 3.3 标记可达对象
- JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图。下图3.0中所展示的JVM中的内存布局可以用来很好地阐释这一概念：
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-db98b5d3a266c24d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/584/format/webp)
- 首先，垃圾回收器将某些特殊的对象定义为GC根对象。
    - 所谓的GC根对象包括：
    - （1）虚拟机栈中引用的对象（栈帧中的本地变量表）；
    - （2）方法区中的常量引用的对象；
    - （3）方法区中的类静态属性引用的对象；
    - （4）本地方法栈中JNI（Native方法）的引用对象。
    - （5）活跃线程。
- 接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。
- 存活对象在上图中被标记为蓝色。当标记阶段完成了之后，所有的存活对象都已经被标记完了。其它的那些（上图中灰色的那些）也就是GC根对象不可达的对象，也就是说你的应用不会再用到它们了。这些就是垃圾对象，回收器将会在接下来的阶段中清除它们。关于标记阶段有几个关键点是值得注意的：
    - （1）开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。
    - （2）暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。
    - （3）在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：
        - 1.如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法（可看作析构函数，类似于OC中的dealloc，Swift中的deinit）。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
        - 2.如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。
    - （4）实际上GC判断对象是否可达看的是强引用。
- 当标记阶段完成后，GC开始进入下一阶段，删除不可达对象。


### 04.垃圾回收方式思考
- 引用计数器何时加1？
    - 比如将对象添加到数组和集合；
- 引用计时器何时减1？
    - 比如将对象移除数据或者集合；
- 引用计数器何时出现
    - 创建一个对象，对象里面就有一个引用计数器




### 06.标记垃圾的算法
#### 6.1 处理垃圾的算法有哪些
- 标记-清除
- 复制
- 标记-整理
- 分带收集算法


#### 6.2 标记-清除（Mark-sweep）
- 什么是标记-清除算法
    - 标记—清除算法是最基础的收集算法，为了解决引用计数法的问题而提出。它使用了根集的概念，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。
    - 这是最基础的算法，后续的收集算法都是基于这个算法扩展的。
- 优点和缺点
    - 优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。
    - 缺点：（1）标记和清除过程的效率都不高。（这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量。如图4.1所示。）。（2）标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但却可能没有一个单一区域能够满足这次分配所需的大小，因此本次分配还是会失败（在Java中就是一次OutOfMemoryError）不得不触发另一次垃圾收集动作。
- 算法示意图：
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-acd959b5e0a6d46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp)
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-05ac8d99f632c6c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp)



#### 6.3 复制（Copying）
- 什么是复制算法
    - 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。
    - 当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 
    - 该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。
    - 复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。一种典型的基于Coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。
- 它的优缺点
    - 优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。
    - 缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。
- 算法示意图
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-8c17960b38d46d0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/606/format/webp)
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-f3564647800ab93c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490/format/webp)



#### 6.4 标记-整理（Mark-Compact）
- 什么是标记-整理算法
    - 该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。
    - 此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 
- 它的优缺点
    - 优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。
    - 缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。
- 算法示意图
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-4e3fee929ea6a1e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/575/format/webp)
    - ![image](https://upload-images.jianshu.io/upload_images/3789193-27c645c7700f687b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/511/format/webp)



### 07.分代收集算法分析
#### 7.1 分代收集算法了解
* 这是当前商业虚拟机常用的垃圾收集算法。
    * 分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
* 为什么要运用分代垃圾回收策略？
    * 在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。
    * 试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。



#### 7.2 如何对对象划分
- 将对象按其生命周期划分
* 年轻代(Young Generation)
* 年老代(Old Generation)
* 持久代(Permanent Generation)
* 其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。


#### 7.3 年轻代对象说明
* 是所有新对象产生的地方。
* 年轻代被分为3个部分——Enden区和两个Survivor区（From和to）
* 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。



#### 7.4 年老代对象说明
* 在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。这时候MajsorGC会清理些老年代垃圾，通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
* 持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 



#### 7.5 分代收集器类型
- Java 提供多种类型的垃圾回收器。 JVM 中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。
- Serial 收集器：新生代收集器，使用复制算法，使用一个线程进行 GC，串行，其它工作线程暂停。
- ParNew 收集器：新生代收集器，使用复制算法，Serial 收集器的多线程版，用多个线程进行 GC，并行，其它工作线程暂停。 使用 -XX:+UseParNewGC 开关来控制使用 ParNew+Serial Old 收集器组合收集内存；使用 -XX:ParallelGCThreads 来设置执行内存回收的线程数。
- Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注 CPU 吞吐量，即运行用户代码的时间/总时间。 使用 -XX:+UseParallelGC 开关控制使用 Parallel Scavenge+Serial Old 收集器组合回收垃圾。
- Serial Old 收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。
- Parallel Old 收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与 Parallel Scavenge 差不错，使用标记整理算法，在 Parallel Old 执行时，仍然需要暂停其它线程。
- CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用 -XX:+UseConcMarkSweepGC 进行 ParNew+CMS+Serial Old 进行内存回收，优先使用 ParNew+CMS，当用户线程内存不足时，采用备用方案 Serial Old 收集。






### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e








