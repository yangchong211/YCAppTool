#### 目录介绍
- 01.分析内存模型背景
    - 1.1 为何分析内存模型
    - 1.2 如何着手学习
    - 1.3 学习内存那些东西
- 02.看内存分配案例
    - 2.1 首先看代码案例
    - 2.2 JVM加载类过程
    - 2.3 对构造方法赋值
    - 2.4 通过对象调用方法
    - 2.5 对对象进行回收
    - 2.6 内存泄漏是啥回事
    - 2.7 堆和栈区别举例
    - 2.8 成员和局部变量
    - 2.9 了解下对象内存结构
- 03.运行时数据区域
    - 3.1 按照私有划分
- 04.线程私有区域
    - 4.1 程序计数器
    - 4.2 虚拟机栈
    - 4.3 本地方法栈
- 05.线程共享区域
    - 5.1 Java堆
    - 5.2 方法区
    - 5.3 运行时常量池
    - 5.4 直接内存
- 06.内存泄漏和溢出
    - 6.1 内存溢出
    - 6.2 为何会内存泄漏
    - 6.3 OOM异常如何理解


### 01.分析内存模型背景
#### 1.1 为何分析内存模型
- 为何要内存优化
    - App消耗内存过大，导致手机内存低于内存警戒线的时候，Low Memory Killer机制就会触发，App占用内存越多，被处理掉的机会就越大。
    - 受虚拟机堆内存限制，出现OOM,内存溢出，程序出现crash。
- 内存如何优化
    - 随着app开发，代码功能越来越多，内存优化就非常重要了。那么内存优化的首要条件，就是了解内存是如何分配，如何回收等等基础知识。因此掌握内存模型很重要！



#### 1.2 如何着手学习
- 重点学习


#### 1.3 学习内存那些东西
- 如下所示
    - ![Java内存分配机制.png](http://upload-images.jianshu.io/upload_images/4432347-473742e2612d5a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 02.看内存分配案例
#### 2.1 首先看代码案例
- 以下面代码为例，来分析，Java 的实例对象在内存中的空间分配。
    ``` java
    //JVM 启动时将 Person.class 放入方法区
    public class Person {
    
        //静态变量，直接放到常量池中
        public static final String number = "13667225184";
        
    	//new Person 创建实例后，name 引用放入堆区，name 对象放入常量池
        private String name;
    
    	//new Person 创建实例后，age = 0 放入堆区
        private int age;
    
    	//Person 方法放入方法区，方法内代码作为 Code 属性放入方法区
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
    	//toString 方法放入方法区，方法内代码作为 Code 属性放入方法区
        @Override
        public String toString() {
            return "Person{" + "name='" + name + '\'' + ", age=" + age + '}';
        }
    }
    
    //JVM 启动时将 Test.class 放入方法区
    public class Test {
    
    	//main 方法放入方法区，方法内代码作为 Code 属性放入方法区
        public static void main(String[] args) {
            //局部变量，定义的一些基本类型的变量和对象的引用变量都是在函数的栈(本地方法栈)内存中分配
            String name1 = "张三";
            int age1 = 18;
  
            //person1 是引用放入虚拟机栈区，new 关键字开辟堆内存 Person 自定义对象放入堆区
            //堆内存用于存放所有由new创建的对象（内容包括该对象其中的所有成员变量）和数组。
            Person person1 = new Person(name1, age1);
            Person person2 = new Person("李四", 20);
    
            //通过 person 引用创建 toString() 方法栈帧
            person1.toString();
            person2.toString();
        }
  
        private void clear(){
            //对象设置为null，回收
            person1 = null;
            person2 = null;
        }
    }
    ```
- 简单说一下加载的流程
    - 首先将 Test.class 放入方法区，然后执行 main 方法放到方法区
    - 通过 new 创建对象，那么对象放到堆中，引用(有的叫指针)放到虚拟机栈中
    - 最后通过引用创建方法栈帧



#### 2.2 JVM加载类过程
- 首先 JVM 会将 Test.class, Person.class 加载到方法区，找到有 main() 方法的类开始执行。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-c0c8abfdd8a82469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 分析步骤
    - 如上图所示，JVM 找到 main() 方法入口，创建 main() 方法的栈帧放入虚拟机栈，开始执行 main() 方法。
    - Person person1 = new Person("张三", 18);
    - 执行到这句代码时，JVM 会先创建 Person。实例放入堆区，person2 也同理。



#### 2.3 对构造方法赋值
- 创建完 Person 两个实例，main() 方法中的 person1，person2 会指向堆区中的 0x001，0x002（这里的内存地址仅作为示范）。紧接着会调用 Person 的构造函数进行赋值，如下图：
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-ac835ce74a470330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 如上图所示，新创建的的 Person 实例中的 name, age 开始都是默认值。
    - 调用构造函数之后进行赋值，name 是 String 引用类型，会在常量池中创建并将地址赋值给 name，age 是基本数据类型将直接保存数值。
    - 注：Java 中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte, Short, Integer, Long, Character, Boolean，另外两种浮点数类型的包装类则没有实现。

    | 基本数据类型	| 包装类(是否实现了常量池技术)  |
    | :---------	| :-----------------------		|
    | byte			| Byte	是						|
    | boolean		| Boolean	是					|
    | short			| Short	是						|
    | char			| Character	是					|
    | int			| Integer	是					|
    | long			| Long	是						|
    | float			| Float	否						|
    | double		| Double	否					|




#### 2.4 通过对象调用方法
- Person 实例初始化完后，执行到 toString() 方法，同 main() 方法一样 JVM 会创建一个 toString() 的栈帧放入虚拟机栈中，执行完之后返回一个值。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-c1ba92593ba35d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 2.5 对对象进行回收
- 如何对对象进行回收，这里说的是主动手动回收
    ``` java
    private void clear(){
        person1 = null;
        person2 = null;
    }
    ```

#### 2.6 内存泄漏是啥回事
- 典型内存泄漏案例
    ```
    Vector v = new Vector(10);
    for (int i = 1; i < 100; i++) {
        Object o = new Object();
        v.add(o);
        o = null; 
    }
    ```
- 分析
    - 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。
    - 因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。




#### 2.7 堆和栈区别举例
- 代码如下所示
    ``` java
    public class Sample() {
        int s1 = 0;
        Sample mSample1 = new Sample();
        public void method() {
            int s2 = 1;
            Sample mSample2 = new Sample();
        }
    }
    
    Sample mSample3 = new Sample();
    ```
- Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。
- mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。


#### 2.8 成员和局部变量
- 接着上面案例可以知道
    - 成员变量全部存储在堆中（包括基本数据类型，引用及引用的对象实体），因为他们属于类，类对象最终还是要被new出来的
    - 局部变量的基本数据类型和引用存在栈中，应用的对象实体存储在堆中。因为它们属于方法当中的变量，生命周期会随着方法一起结束


#### 2.9 了解下对象内存结构
- 对象的内存结构
    - 对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
    - ![image](https://img-blog.csdnimg.cn/2021011014434558.png)
- 对象头的结构
    - HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为"Mark Word"。
    - 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。




### 03.运行时数据区域
#### 3.1 按照私有划分
- Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。这些组成部分一些事线程私有的，其他的则是线程共享的。
- **线程私有的：**
    - 程序计数器
    - 虚拟机栈
    - 本地方法栈
- **线程共享的：**
    - Java堆
    - 方法区
    - 运行时常量池
    - 直接内存
- 结构图
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-a7bbacca96a92dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 那么jvm为何这样划分数据区域呢？



### 04.线程私有区域
#### 4.1 程序计数器
- 程序计数器
    - 是一个数据结构，用于保存当前正常执行的程序的内存地址。
    - Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。
- 程序计数器是一块较小的内存空间
    - 可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**
- 程序计数器主要有两个作用：
    - 1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
    - 2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿。
- **注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



#### 4.2 虚拟机栈
- Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。
- **Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。**（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）
- **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
- **Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**
    - **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
    - **OutOfMemoryError：** 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
- Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。


#### 4.3 本地方法栈
- 本地方法栈：跟虚拟机栈很像， **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
- 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。


### 05.线程共享区域
#### 5.1 Java堆
- Java堆：所有线程共享的一块内存区域。
    - 此内存区域的唯一目的就是存放对象实例，对象实例几乎都在这分配内存。在虚拟机启动时创建。
- Java 堆是垃圾收集器管理的主要区域
    - 我们讨论的内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。
    - 因此也被称作**GC堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：在细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-99889839cf683c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 堆内存是一块不连续的内存区域
    - 如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能。
- 在 JDK 1.8中移除整个永久代
    - 取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。




#### 5.2 方法区
- 方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。
    - 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
- **相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**如何理解这句话？


#### 5.3 运行时常量池
- 运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。
    - 。Class 文件中包括类的版本、字段、方法、接口等描述信息 
- 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。**JDK1.7及之后版本的 JVM已经将运行时常量池从方法区中移了出来，在Java堆（Heap）中开辟了一块区域存放运行时常量池。** 



#### 5.4 直接内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。
- JDK1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。
- 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。


### 06.内存泄漏和溢出
#### 6.1 内存溢出
- Java中堆和栈的区别？
    - 栈内存：主要用来存放基本数据类型和局部变量；当在代码块定义一个变量时会在栈中为这个变量分配内存空间，当超过变量的作用域后这块空间就会被自动释放掉。
    - 堆内存：用来存放运行时创建的对象，比如通过new关键字创建出来的对象和数组；需要由Java虚拟机的自动垃圾回收器来管理。
- 分别写出堆内存溢出与栈内存溢出的程序？
    - 栈内存溢出
    ```
    public void A() {
        A();
    }
    ```
    - 堆内存溢出
    ```
    public void testd() {
        List<String> list = new ArrayList<>();
        int i = 0;
        while (true) {
            list.add(new String(i + ""));
            i++;
        }
    }
    ```

#### 6.2 为何会内存泄漏
- Java采用GC进行内存管理。
    - Android虚拟机的垃圾回收采用的是根搜索算法。GC会从根节点（GC Roots）开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。
    - 而内存泄漏出现的原因就是存在了无效的引用，导致本来需要被GC的对象没有被回收掉，从而导致内存泄漏。


#### 6.3 OOM异常如何理解
- OutOfMemoryError异常在哪些数据区域中可能会出现？
    - Java堆溢出
    - 虚拟机栈和本地方法栈溢出
    - 方法区和运行时常量池溢出
- Java堆溢出
    - Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常
    - 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
    - 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
- 虚拟机栈和本地方法栈溢出
    - 对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：
    - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError
    - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
    - 在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常
    - 如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程
- 方法区和运行时常量池溢出
    - String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
    - 由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - Intern():JDK1.6 intern方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个


















