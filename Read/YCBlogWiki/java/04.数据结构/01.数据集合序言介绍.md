#### 目录介绍
- 01.学习集合序言
- 02.思考n个问题
- 03.集合特有侧重点
- 04.常用的集合分类
- 05.集合一些总结


### 00.一些常见问题思考
- Java集合框架中有哪些类？都有什么特点？集合框架用到Collection接口，这个接口有何特点？


### 01.学习集合序言
- 很多写程序的人都听说过一个公式，程序 = 算法 + 数据结构。
    - 而在 Java 中，自身已经提供了丰富的集合，来帮助我们处理和管理数据，但是多数情况下，我们比较常用的就那么几个，可这并不妨碍我们学习了解其他「冷门」的集合类。
- 但是集合类那么多，怎么学？
    - 一个一个方法看其内部实现？我想你就算耐着性子看完了，没几天也都忘干净了，因为细节太多了，同时使用的频率低，遗忘是必然的。
    - 所有的集合类都是为数据和业务服务的，对外无外乎就是增删改查几种操作，对内无法避免的还有一些例如初始化、数据的维护、动态扩容等等实现，细节都在内部。
- 在学习集合类的时候怎么做？
    - 应该保持一个清晰的主线，只关注几个重要的问题，你就可以还原对这个集合的认识。



### 02.思考n个问题
- 比如我在看一个集合类的时候，会思考三个问题：
    - 它擅长解决什么数据问题？（或者说它以解决什么数据问题为目标？）
    - 它如何解决这些问题？
    - 为了解决这些问题，引入了什么新的问题，它是如何平衡的？



### 03.集合特有侧重点
- 程序的世界里，没有银弹，否则其他集合就没有了存在的必要。
    - 也就是说每个集合一定有不同的侧重点，它在时间和空间上，一定是有所取舍，有所平衡，在这个目标下，做出最合适的优化实现。
- 就拿 HashMap 来举例子
    - 它作为一个工业级的集合类，其中有不少复杂的实现细节，用哈希表让查询的时间复杂度达到 O(1)，但是「哈希冲突」是它需要面对的问题，所以它采用「拉链法」的方式解决冲突，又因为链表会让时间复杂度在极端情况下退化到O(n)，又引入了红黑树，以保证在最恶劣的情况下时间复杂度也不会退化的太严重。



### 04.常用的集合分类
#### 4.1 集合的由来
* 面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类。


#### 4.2 数组和集合的区别
* (1): 长度区别: 数组的长度是固定的而集合的长度是可变的
* (2): 存储数据类型的区别: 数组可以存储基本数据类型 , 也可以存储引用数据类型; 而集合只能存储引用数据类型
* (3): 内容区别: 数组只能存储同种数据类型的元素 ,集合可以存储不同类型的元素


#### 4.3 集合继承体系图
- ![image](https://upload-images.jianshu.io/upload_images/4432347-492ac09cb88c5b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 4.4 Collection功能概述
- a:添加功能
	* boolean add(Object obj):添加一个元素
	* boolean addAll(Collection c):添加一个集合的元素
- b:删除功能
	* void clear():移除所有元素
	* boolean remove(Object o):移除一个元素
	* boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有)
- c:判断功能
	* boolean contains(Object o)：判断集合中是否包含指定的元素   
	* boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有)
	* boolean isEmpty()：判断集合是否为空
- d:获取功能
	* Iterator<E> iterator()(重点)
- e:长度功能
	* int size():元素的个数
	* 面试题：数组有没有length()方法呢?字符串有没有length()方法呢?集合有没有length()方法呢?
- f:交集功能
	* boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢?
- g:把集合转换为数组
	* Object[] toArray()


#### 4.5 集合分类
- **如下图所示：**
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-84cb744b434c0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-95c1a4cac03f1510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **常见的集合数据**
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-99e078e9f90f1366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 4.6 数据的说明
- **数组**
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-44f75cb827c7ce06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	* 无序数组
		* 优点：查询快,如果知道索引可以快速地存取
		* 缺点：删除慢,大小固定
	* 有序数组
		* 优点：比无序数组查找快
		* 缺点：删除和插入慢，大小固定
- **栈**
	* 优点：提供后进先出的存取方式
	* 缺点：存取其他项很慢
	* 比如，Android中管理activity进出就是使用栈
- **队列**
	* 优点：提供先进先出的存取方式
	* 缺点：存取其他项都很慢
- **链表**
	* 优点：插入快，删除快
	* 缺点：查找慢(一个个节点查)
- **二叉树**
	* 优点：查找，插入，删除都快（平衡二叉树）
	* 缺点：删除算法复杂
- **红-黑树**
	* 优点：查找，插入，删除都快，树总是平衡的(局部调整)
	* 缺点：算法复杂
- **哈希表**
	* 优点：如果关键字已知则存取速度极快，插入快
	* 缺点：删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分
- **堆**
	* 优点：插入，删除快，对最大数据的项存取很快
	* 缺点：对其他数据项存取很慢
- **图**
	* 优点：对现实世界建模
	* 缺点：有些算法慢且复杂



### 05.集合一些总结
#### 5.1 集合总结
- ![image](https://upload-images.jianshu.io/upload_images/4432347-760b4c34becd66c1.png)


#### 5.2 List集合
- List总结梳理
    - ArrayList：基于动态数组实现，支持随机访问；线程不安全；底层由数组实现（顺序表），因为由顺序表实现，所以会具备顺序表的特点。
    - Vector：和 ArrayList 类似，但它是线程安全的。
    - LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。
- 如何选择合适list
    - 对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList。
    - LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。
    - 对于Vector而已，我们一般都是避免使用。（ArrayList可用通过Collections中的方法转换为线程安全类）
    - 将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。
- List集合读写机制
    - ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。
    - LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。
    - Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；如果capacityIncrement<=0,则将Object数组的大小扩大为现有大小的2倍。
- List集合读写效率
    - ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。
    - LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。




#### 5.3 Map集合
- Map集合从何而来
	* 我们通过什么东西来标识我们的学生在班级的唯一性. 我们都每一个学生应该存在一个学号 , 而这个学号是唯一的。那么我们就可以通过这个学号来表示我们学生在班级的唯一性。那么也就说,我们的学号和学生的姓名之间应该存在一个对应关系吧
	* 那么我们怎么存储这样对应关系的数据呢?针对这个情况java就给我们提供了另外一种集合进行表示,而这个集合就是Map 。Map集合结构是由两列组成,第一列被称之为键 , 第二例被称之为值 ; 并且我们都知道键应该是唯一的，而对值没有要求。
    ```
    学号          姓名
    stu001        张三
    stu002        李四
    stu003        王五
    stu004        王五
    stu005        杨充逗比
    ```
- Collection集合和Map集合的区别？
	* Map集合由两列组成(双列集合) , 而Collection集合由一列组成(单列集合) ;  Map集合是夫妻对 , Collection孤狼
	* Collection集合中的Set集合可以保证元素的唯一性 , 而Map集合中的键是唯一的
	* Collection集合的数据结构是对存储的元素是有效的,而Map集合的数据结构只和键有关系,和值没有关系
- Map集合主要有哪些
    - TreeMap：基于红黑树实现。
    - HashMap：基于哈希表实现。
    - HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
    - LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
- Map集合的特点
	* 将键映射到值的对象
	* 一个映射不能包含重复的键
	* 每个键最多只能映射到一个值



- **2. Set**
    - TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
    - HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
    - LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

- **4. Queue**
    - LinkedList：可以用它来实现双向队列。
    - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
- Java带有一组接口和类，使得操作成组的对象更为容易，这就是集合框架
    - 集合框架主要用到的是Collection接口，Collection是将其他对象组织到一起的一个对象，提供了一种方法来存储、访问和操作其元素
    - List、Set和Queue是Collection的三个主要的子接口。此外，还有一个Map接口用于存储键值对
        |接口|描述|
        |:----|:--|
        |Collection|Collection是最基本的集合接口，一个 Collection 代表一组Object，Java不提供直接继承自Collection的类，只提供继承于它的子接口|
        |List|List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引来访问List中的元素，而且允许有相同的元素|
        |Set|Set具有与Collection完全一样的接口，只是行为上不同，Set不保存重复的元素|
        |Queue|Queue通过先进先出的方式来存储元素，即当获取元素时，最先获得的元素是最先添加的元素，依次递推|
        |SortedSet|继承于Set保存有序的集合|
        |Map|将唯一的键映射到值|
        |Map.Entry|描述在一个Map中的一个元素（键/值对），是一个Map的内部类|
        |SortedMap|继承于Map，使Key保持在升序排列|


#### 5.2 Hashcode与equal区别
- 同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上











