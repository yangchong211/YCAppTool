#### 目录介绍
- 01.QA需求执行规范
- 02.QA工时评估依据
- 03.移动端测试case
- 04.开发自测规范点



### 01.QA需求执行规范
#### 1.1 背景
- QA接到大型需求测试时
    - 涉及到人员数目多、部门数目多、业务复杂度高，针对一个大型需求测试时各环节是否做到位决定了需求是否延期以及需求是否能保证高质量上线标准，为此列出大型需求测试时需要沉淀的规范。


#### 1.2 执行内容
- 1.粗评细评: 列出此需求功能点，比如包括哪些功能点，分别哪几个部门哪几个人员在做此功能
- 2.技术评审: 列出技术评审相关结论，比如技术提到注意点
- 3.前期准备: 列出前期准备事项，如合作部门人员确定，排期确定，数据账号准备
- 4.case编写:
    - case评审结论与实际设计差异修正，其中包括产品提出case设计不符、rd提出case设计不符
    - case设计内容是否到位，其中测试类型包括接口字段测试、功能逻辑测试、异常测试、兼容性测试、性能测试等；
    - case执行环节是否到位，其中环节包括准入测试环节、case联调环节、case pre环节、case上线环节、回归测试环节等
- 5.bug总结: 列出此需求发现多少个bug，分别为哪几类问题，是否有遗留问题
- 6.需求场景构造总结: 测试过程中如何构造出这个需求场景，举例push需求，通过哪些平台怎么操作能发push
- 7.测试总结: 合作过程中遇到哪些问题


### 02.QA工时评估依据
#### 2.1 背景
- QA对每个需求测试时间直接决定QA测试效率
    - QA工时评估的合理性也是对QA工作效率评定的标准之一，所以针对QA接收每一个需求所要的时间花费做一个详情列举，同时作为qa工时评估的依据


#### 2.2 时间花费详情
- 1.需求阶段
    - 参与需求粗评、细评，了解需求细节功能点，确认疑惑点
    - 参与技术评审，了解需求技术实现细节，确认case设计注意点
    - 测试数据准备，准备需求对应需要的测试账号及环境，配合rd开发调试阶段的数据构造
- 2.测试阶段
    - case设计，根据评审结果编写功能case
    - case评审，核对case设计与rd及产品需求是否一致
    - 需求功能测试，针对case对功能实现的验证、UI的验收、产品的验收，编写bug及跟踪bug至最后关闭
    - 参与ET测试，记录ET测试问题及跟踪bug至最后关闭
    - 与后端qa联调，针对case在测试环境与后端qa联调功能是否正常
    - 后端上pre后，针对case在pre环境下验证功能是否正常
    - 后端上线后，针对case在线上环境下验证功能是否正常
    - 兼容性测试，涉及系统为android 5-11、ios10-15，涉及手机型号见：D端测试机使用，涉及app版本为国际版及巴西版
    - 回归测试，包括此次需求在巴西及国际版本各两端的回归包上的验证以及主流程case回归
- 3.发布阶段
    - 灰度crash的关注及线上问题处理；版本或需求的总结及知识沉淀
- 4.其它
    - 需求测试过程中，周会、临时、非跟版需求、跨版本需求的会议
    - 需求测试过程中，线上问题验证与处理
    - 需求测试过程中，根据其它业务部门的需求进行协助与验证工作
    - 版本跟进过程中，与服务端qa、rd、产品及其它部门的协调工作




### 03.移动端测试case
#### 3.1 背景说明
- 为了保证客户端case编写一致性，提高测试用例的可读性、复用性、可维护性。减少新同学的学习成本，提高用例执行效率。


#### 3.2 基本原则
- 编写case的基本原则为：
- 一条case有且仅有唯一的验证点，每个操作对应唯一结果，且操作步骤是连续可执行的，操作步骤最多不超过五步。
- 有效case的特点是：用最少的用例覆盖最全的功能，即将一些简单验证逻辑融合至复杂逻辑的操作步骤中。


#### 3.3 case结构
- 编写case使用工具：Xmind
- Case结构由项目名-模块名-用例名称-操作步骤-预期结果组成。


#### 3.4 名词定义
- 项目名：可以是乘客端版本或非版本项目名称
- 模块的划分：模块的划分可以有两种方法，一种是根据页面不同分别进行划分（例如：列表页、详情页），另外一种是根据功能划分，及时显示在不同页面但可以归纳在一起验证。当两种划分方法同时使用时，功能交叉部分仅写一次即可。
- case名称描述：简单概要的描述需要验证的逻辑点，禁仅写一个名词、一个页面。


### 04.开发自测规范点
- App质量问题是个很大的Topic，为了最终达成优秀的线上质量，需要在全流程各个环节都通过流程与技术相结合的方式做好约束。
- QA只是质量保证的一个环节，且较为后置，研发更应该对自己的交付质量做好前置性的保障，自测是个很重要的环节。
- 业务场景复杂，自测要关注的维度很多，在尽可能保证效率的情况下要提高自测质量，需要一套可行且全面的自测规范来引导思路，梳理了一套规范，主要包括6个方面：
- 兼容性覆盖；多端覆盖；异常覆盖；接口健壮性；核心流程覆盖；新老版本覆盖。


#### 4.1 兼容性覆盖
- 说明：App开发受限于Android/iOS系统变更和一些机型碎片化问题，兼容性问题是经常被提及的重要方面，但不是所有代码都涉及到兼容性问题。
- 准则：一般认为与系统/机型的差异化密切相关的高危点需要做兼容性测试。
- 场景：大规模的功能改版/重构，无需原因，必须做兼容性覆盖；SDK更新也需要注意兼容性；


#### 4.2 多端覆盖
- 说明：既要保证功能在多个产物的稳定性，又要尽可能提高效率。
- 准则：一般认为在时间充足的情况下应该做全端测试，在时间有限的情况下应该对一些多端敏感型场景做好覆盖测试。


#### 4.3 异常覆盖
- 说明：大部分情况下，产研都只关注到了正常的业务主流程，但对于很多异常分支（包括业务异常分支、代码异常分支）关注不够，导致后期花大量时间对异常情况做处理，时刻保持异常覆盖意识才能避免后期的被动。
- 准则：一般认为代码中涉及到if-else、onFailure、onException、null、empty、nil 等场景，需要做异常覆盖测试。
- 场景：
    - 网络数据请求，只关注data != null，error_code = 0的情况，忽略可能出现的网络/服务异常/时序问题
    - try-catch代码中，只处理try不处理catch，上线后出现严重的异常状态或执行流程
    - 只对异常分支逻辑提供了 Assert 断言，便于在 DEBUG 模式下发现问题，而未对异常分支逻辑进行降级处理，易造成线上逻辑错误
    - 对List类型数据做remove、insert等操作时，不考虑列表长度可能为空、为1时的range异常，导致严重Crash


#### 4.4 接口健壮性
##### 4.4.1 测试方式如下
- 1.方法：利用charles将被测接口抓取到，然后分别将接口中每一个字段进行mock，mock结束后查看端上的反应。
- 2.找到测试目标页面的接口为：https://d.didi-food.com/rider/user/multicard
- 3.打开charles，抓取到multicard接口。将返回的数据保存到本地为一个json文件，如multicard.json，内容为上述抓到接口里返回的内容
- 4.在charles里右击multicard，选择maplocal。在charles里点击choose按钮，将3步骤里保存好的json文件选择进去
- 5.修改本地保存的json文件字段，查看目标页面的内容展示，如mock字段title为空，然后查看效果


##### 4.4.2 需要测试的范围及期望验证的结果
- 1.字段的value为字符串，如"title":"xxx"
    - 返回为空，查看端上是否会闪退、ui展示是否异常
    - 返回为null，查看端上是否是闪退、ui展示是否异常
    - 返回为正常支持的字符内容及长度，查看端上ui展示是否异常
    - 返回为超长字符长度，查看端上ui展示是否异常
- 2.字段的value为整型，如"errno":0
    - 返回为负数，查看端上是否会闪退、ui展示是否异常
    - 返回为0，查看端上ui展示是否异常
    - 返回为超大的数，查看端上是否会闪退、ui展示是否异常
- 3.字段的value为一个集合，如"data":{}
    - 返回的集合为空，查看端上是否会闪退、ui展示是否异常
    - 返回的集合为null，查看端上是否会闪退、ui展示是否异常
    - 返回有集合有值，查看端上ui展示是否异常
- 4.字段的value为一个数组，如"list":[]
    - 返回的数组为空，查看端上是否会闪退、ui展示是否异常
    - 返回的数组为null，查看端上是否会闪退、ui展示是否异常
    - 返回的数组有值，查看端上ui展示是否异常
    - 返回的数组有N个，查看端上是否会闪退、ui展示是否异常
- 5.字段的value为http的url，如"iconUrl":"http://didi.com.png"
    - 返回的字段为空，查看端上是否会闪退、ui展示是否异常
    - 返回的字段为null，查看端上是否会闪退、ui展示是否异常
    - 返回的字段链接为错误链接，查看端上ui展示是否异常
    - 返回的字段链接为正确链接，查看端上ui展示是否异常
- 6.接口字段的value为boolean，如"isTrue":true
    - 返回的字段为null，查看端上是否会闪退、ui展示是否异常
    - 返回的字段为空，查看端上是否会闪退、ui展示是否异常
    - 返回的字段为true，查看端上ui展示是否异常
    - 返回的字段为false，查看端上ui展示是否异常
- 7.接口响应时间长时端上如何处理，此项根据业务性质做对应的测试
    - 接口响应时间长，端上操作其它功能是否导致bug
    - 接口响应超时，端上是否有异常


#### 4.5 核心流程覆盖
- 说明：核心流程覆盖一般在发版前QA都会做重点关注验证，正常feature级别开发一般不会涉及到核心流程验证，但如果修改面涉及到底层代码、通用业务能力等，是需要做核心流程覆盖的。
- 准则：一般当修改超出单一业务模块边界，且影响主流程环节>1个时，需要做核心流程覆盖测试。



#### 4.6 新老版本覆盖
- 说明：大部分开发测试阶段，都是以当前最新版本为基准，但容易忽略对老版本的覆盖测试，导致上线后老版本出现严重问题。
- 准则：一般当API修改涉及到版本控制，新老版本差异化处理，或端上修改涉及到对老版本缓存数据依赖时，需要做老版本覆盖测试和老版本升级测试。
- 场景:
    - 端上新版本需要依赖老版本在设备中存入的老数据时，例如给某个序列化结构新增/删除/修改字段，且该序列化结构已经被老版本写入本地缓存，需要覆盖两个场景：
    - 在不清理应用数据的情况下，用老版本做直接覆盖升级并测试
    - 完全清理应用数据，模拟新用户安装后无缓存场景做测试（例如首页启动逻辑，有无缓存是两个分支）






