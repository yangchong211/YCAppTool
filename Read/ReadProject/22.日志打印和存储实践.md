#### 目录介绍
- 01.整体概述
    - 1.1 项目背景说明
    - 1.2 考虑的事情
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.日志存储设计
    - 2.1 日志存储总体设计
    - 2.2 存储日志信息设计
    - 2.3 日志保存策略设计
    - 2.4 独立进程写数据
    - 2.5 存储数据队列设计
    - 2.6 如何写数据的设计
- 03.方案基础设计
    - 3.1 整体架构图
    - 3.2 UML设计图
    - 3.3 关键流程图
    - 3.4 接口设计图
    - 3.5 模块间依赖关系
- 04.日志存储设实践
    - 4.1 使用跨进程通信
    - 4.2 选择Service通信
    - 4.3 日志文件路径设置
    - 4.4 组装log日志设计
    - 4.5 日志文件创建机制
    - 4.6 日志缓存的策略
    - 4.8 日志存储GZip压缩
    - 4.9 多进程存储问题
- 05.关键技术点说明
    - 5.1 aidl通信步骤
    - 5.2 跨进程启动服务
    - 5.3 跨进程传输日志
    - 5.4 日志写入操作
    - 5.5 日志如何追加写入
    - 5.6 日志切分存储
    - 5.7 日志自动清除操作
    - 5.9 遇到的一些问题
- 06.使用高效日志库
    - 6.1 高效日志方案
    - 6.2 mmap理解介绍
    - 6.3 移动端使用mmap
    - 6.4 XLog介绍
    - 6.5 Logan介绍
    - 6.6 MMKV介绍
- 07.其他设计说明
    - 7.1 性能设计
    - 7.2 稳定性设计
    - 7.3 灰度设计
    - 7.4 降级设计
    - 7.5 异常设计


### 01.整体概述
#### 1.1 项目背景说明


#### 1.2 考虑的事情
- 日志系统设计需要考虑的问题：
    - 1.需要保证日志系统收集到的数据的有效性和完整性，在app崩溃时日志不丢失。
    - 2.保证收集日志的过程不影响app的性能，不能占用过高cpu资源，或者频繁IO造成卡顿现象。


#### 1.3 基础概念介绍
- 常见术语概念解析
    - appender：主要控制日志输出到哪里，比如：文件、数据库、控制台打印等
    - logger: 用来设置某一个包或者具体某一个类的日志打印级别、以及指定appender


#### 1.4 设计目标


#### 1.5 产生收益分析


### 02.日志存储设计
#### 2.1 日志存储总体设计



#### 2.2 存储日志信息设计
- 比如，打印日志如下所示：
    - LogUtils.i("Log test info : click text view test")
- 日志组装后输出到控制台
    - yc_log:: [(LogTestActivity.kt:110)#OnClick] Log test info : click text view test
    - 携带方法和的类的源文件行号，支持点击跳转到源文件。
- 那么如何组装数据
    - 获取当前堆栈信息，然后获取指定索引处的className和methodName。也就是：(LogTestActivity.kt:110)#OnClick
    - 从中获取方法执行的线程相关的信息，以及执行的方法名称等。这些信息能帮助我们更好的查找问题之所在。



#### 2.3 日志保存策略设计
- 日志保存策略设计大概如下
    - 由于保存日志的过程是个耗时过程，我们需要开启线程去保存。但是日志产生的频率可能很高，又不能采用一般的线程去处理，太多的线程也会损耗性能。所以应该考虑队列的形式保存日志，然后一条一条的去保存。


#### 2.4 独立进程写数据
- 使用独立的进程去写数据
    - 第一步：在初始化的时候，bind绑定一个Service，主要是建立进程通信连接。然后获取aidl接口对象。


#### 2.5 存储数据队列设计
- 采集一次日志就保存到file文件中吗
    - 这个采集过程，如果是每产生一次日志数据，就写一次文件，势必造成系统IO调用的频繁操作，可能会造成app运行卡顿现象。因此采用队列保存日志，当达到某数值则开始写入到文件，简单来说是追加写入。
- 队列缓存大小，单位(条)，也可以动态修改容积。
    - 比如进入日志高频触发区，则将缓存容积扩大到100条，进入低频触发区就缩小到10条。容积缩小时，如果缓存内条目数已经大于目标条数，自动触发flush。
- 在初始化的时候，创建一个日志队列线程并开始
    - 开启while循环，从日志队列取数据，如果有数据则doFlush()发送到LogService，通过Aidl进行数据发送。



#### 2.6 如何写数据的设计
- 如何写数据的设计
    - 创建Writer对象，调用writer.write(string)进行写入数据。
- flush写数据时机，粗略分为四种情况：
    - 缓存池满、应用从前台进入后台、应用从后台恢复至前台、手动代码调用。手动代码调用一般发生在进入超高频触发区之前，或者是跨功能模块时，以及用户交互需求日志上传时。



### 02.日志存储设计思路
#### 2.1 使用跨进程写日志


#### 2.2 选择Service通信
- 使用Service服务场景：后台运行和跨进程访问
    - 后台运行，Service可以在后台执行长时间运行操作而不提供用户界面；跨进程访问，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。
- 开启远程服务(Remote Service)
    - 该服务是独立的进程，对应进程名格式为所在包名加指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。
- 使用Service服务技术选择
    - 如果只是想开个服务在后台运行的话，直接startService即可；如果需要相互之间进行传值或者操作的话，就应该通过bindService。
    - 需要注意的点有哪些：Service是在主线程里执行操作的，可能会因为执行耗时操作而导致ANR。如果是跨进程传输，则需要注意读写耗时。


#### 2.3 日志文件路径设置
- 首先给客户端设置路径，然后在通过aidl跨进程传递给服务端。
    - 这里面需要注意，在bind绑定service后，在onServiceConnected连接上之后，调用IxxService.Stub.asInterface(IBinder obj) 即可得到一个IxxService实例，即客户端这边通过实例调用接口(aidl)中方法传递路径



#### 2.4 组装log日志设计



#### 2.5 日志文件创建机制



#### 2.6 日志缓存的策略


#### 2.8 日志存储GZip压缩
- https://juejin.cn/post/7083634028640731143


#### 2.9 多进程存储问题


### 03.关键技术点说明
#### 3.1 aidl通信步骤
- 服务端
    - 步骤1：新建定义AIDL文件【特别注意包名保持一致】，并声明该服务需要向客户端提供的接口。补充，如果aidl中有对象，则需要创建对象，并且实现Parcelable
    - 步骤2：在Service子类中实现AIDL中定义的接口方法，并定义生命周期的方法
    - 步骤3：在AndroidManifest.xml中注册服务 & 声明为远程服务
- 客户端
    - 步骤1：拷贝服务端的AIDL文件到目录下【需要把service端所有的aidl都拷贝到client来】
    - 步骤2：使用Stub.asInterface接口获取服务器的Binder，根据需要调用服务提供的接口方法
    - 步骤3：通过Intent指定服务端的服务名称和所在包，绑定远程Service
- 遇到一些问题
    - aidl接口是如何定义？
    - 定义后aidl接口如何编译生成.java文件？
    - aidl通信是单向还是双向？单向通信，客户端调
    - 其他注意点：注意的是需要先启动service端的apk，在启动client端的apk
- 不同的场景
    - 场景一、service 和 client 在同一个 project 中。service项目可以直接依赖client项目
    - 场景二、service 和 client 分属于不同的 project 中。将service项目中的 aidl 文件夹原封不动的拷贝到client项目中的对应位置




#### 3.2 跨进程启动服务


#### 3.3 跨进程传输日志


#### 3.4 日志写入操作


#### 3.5 日志如何追加写入


#### 3.6 日志切分存储


#### 3.7 日志自动清除操作


#### 3.9 遇到的一些问题
- 跨进程启动Service无效
    - 在manifest注册的时候加了process属性，然后就无法启动了，去掉就可以正常启动的？
- 客户端在
    - 客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。



### 04.使用高效日志库
#### 4.1 高效日志方案
- 移动日志系统使用了Linux系统中提供的mmap作为日志文件的载体
    - 目前业内流行的XLOG日志组件、MMKV、美团Logan均采用了此方案，其最大的优势就是高效I/O、低损耗、跨进程 等优势。


#### 4.3 移动端使用mmap
- 对于移动端日志采集SDK来说
    - 主要进行的工作就是将用户写入的数据保存到文件中，在这个过程中涉及到在native层调用mmap函数实现在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。


#### 4.4 XLog介绍



#### 4.5 Logan介绍
- 大概的原理介绍
    - Logan通过Native方式来实现日志底层的核心逻辑，也就是C编写底层库。收集日志时，在C层实现流式的压缩和加密数据，可以减少CPU峰值，使程序运行更加顺滑。而且先压缩再加密的方式压缩率比较高，整体效率较高。加密方式为AES。
    - Logan对日志协议数据进行格式化处理，针对大日志的分片处理，引入了MMAP机制解决了日志丢失问题，使用AES进行日志加密确保日志安全性。  
- 使用mmap技术优化
    - mmap: 是一种内存映射文件的方法，它将一个文件映射到进程的地址空间中，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系
    - 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上
      




#### 4.6 MMKV介绍


### 05.方案基础设计
#### 5.1 整体架构图


#### 5.2 UML设计图


#### 5.3 关键流程图


#### 5.4 接口设计图


#### 5.5 模块间依赖关系


### 06.其他设计说明
#### 6.1 性能设计


#### 6.2 稳定性设计


#### 6.3 灰度设计


#### 6.4 降级设计


#### 6.5 异常设计




### 07.其他说明介绍
#### 7.1 参考链接
- 京东零售云mPaaS移动端日志回捞探索实践
    - https://www.51cto.com/article/682747.html
- 美团开源移动端基础日志库
    - https://tech.meituan.com/2018/10/11/logan-open-source.html
- Android跨进程启动Service流程及常见问题
    - https://blog.csdn.net/One_Month/article/details/80255893
- Android进阶——AIDL详解
    https://blog.csdn.net/ly0724ok/article/details/117450121/
- Android中AIDL使用案例
    - https://www.jianshu.com/p/b174f14a2d2f
- 货拉拉客户端通用日志组件 - Glog
    - https://juejin.cn/post/7168662263337861133








