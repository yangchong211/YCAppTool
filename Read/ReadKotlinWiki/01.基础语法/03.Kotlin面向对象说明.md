










- 05.修饰符
    - 5.1 public
    - 5.2 protected
    - 5.3 private
    - 5.4 internal
    - 5.5 final和oepn



### 05.修饰符
#### 5.1 public
- public 修饰符是限制级最低的修饰符，是默认的修饰符。如果一个定义为 public  的成员被包含在一个 private  修饰的类中，那么这个成员在这个类以外也是不可见的


#### 5.2 protected
- protected 修饰符只能被用在类或者接口中的成员上。在 Java 中，可以从同一个包中访问一个 protected 的成员，但对于 Kotlin 来说，protected 成员只在类和它的子类中可见


#### 5.3 private
- private  修饰符是限制级最高的修饰符，Kotlin 允许在顶层声明中使用 private 可见性，包括类、函数和属性，这表示只在自己所在的文件中可见，所以如果将一个类声明为 private，就不能在定义这个类之外的地方中使用它。此外，如果在一个类里面使用了 private  修饰符，那访问权限就被限制在这个类里面，继承这个类的子类也不能使用它。所以如果类、对象、接口等被定义为 private，那么它们只对被定义所在的文件可见。如果被定义在了类或者接口中，那它们只对这个类或者接口可见


#### 5.4 internal

如果是一个定义为 internal  的包成员的话，对所在的整个 module  可见。如果它是一个其它领域的成员，它就需要依赖那个领域的可见性了。比如，如果我们写了一个 private  类，那么它的 internal  修饰的函数的可见性就会限制于它所在的这个类的可见性。
我们可以访问同一个 module  中的 internal  修饰的类，但是不能访问其它 module  的



#### 5.5 final和oepn
- Kotlin 中的类和方法默认都是 final 的，即不可继承的，如果想允许创建一个类的子类，需要使用 open 修饰符来标识这个类，此外，也需要为每一个希望被重写的属性和方法添加 open 修饰符
    ```
    open class View {
        open fun click() {
    
        }
    	//不能在子类中被重写
        fun longClick() {
    
        }
    }
    
    class Button : View() {
        override fun click() {
            super.click()
        }
    }
    ```
- 如果重写了一个基类或者接口的成员，重写了的成员同样默认是 open 的。例如，如果 Button 类是 open 的，则其子类也可以重写其 click() 方法
    ```
    open class Button : View() {
        override fun click() {
            super.click()
        }
    }
    
    class CompatButton : Button() {
        override fun click() {
            super.click()
        }
    }
    ```
- 如果想要类的子类重写该方法的实现，可以显式地将重写的成员标记为 final
    ```
    open class Button : View() {
        override final fun click() {
            super.click()
        }
    }
    ```
- 如下所示
    | 修饰符         | 类成员       | 顶层声明     |
    | -------------- | ------------ | ------------ |
    | public（默认） | 所有地方可见 | 所有地方可见 |
    | internal       | 模块中可见   | 模块中可见   |
    | protected      | 子类中可见   |              |
    | private        | 类中可见     | 文件中可见   |













