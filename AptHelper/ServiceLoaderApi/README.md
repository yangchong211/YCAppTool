#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 设计目标
    - 1.4 产生收益分析
- 02.SPI简单案例实现
    - 2.1 实现步骤
    - 2.2 遇到的问题
- 03.SPI机制说明
    - 3.1 SPI是什么
    - 3.2 作用是什么
    - 3.3 SPI设计思想
- 04.SPI封装思路
    - 4.6 如何使用
    - 4.7 SIP拓展原理
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计



### 01.整体概述
#### 1.1 项目背景


#### 1.2 遇到问题
- 1.项目业务组件依赖sdk组件，如何使用组件中功能且减少代码耦合性？


#### 1.3 设计目标


#### 1.5 产生收益分析


### 02.SPI机制说明
#### 2.1 SPI是什么
- SPI ，全称为 Service Provider Interface，是一种服务发现机制。
    - 它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类，一般用来启用框架扩展和替换组件。由jdk提供使用。


#### 2.2 SPI设计思想
- SPI核心思想
    - Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。
- 在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。
    - 一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。
- Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。
    - 有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。


#### 2.3 作用是什么
- 解耦合：
    - 把接口的具体实现类的全名写成配置文件，然后进行读取，生成具体的实现类对象，进行服务的调用，从而实现解耦。



#### 2.3 SPI机制原理


### 03.SPI简单案例实现



### 04.SPI封装思路
#### 4.6 如何使用
- 举一个案例
    - 比如想实现一个推送的功能，不管是在那个组件中能快速使用，减少耦合性。核心还是用到接口+实现类+反射创建对象的形式。
    - 注解类：ServiceProvider，ServiceProviderInterface。注意注解标注是运行时……
    - 定义推送的接口：PushServiceProvider，使用注解ServiceProviderInterface标记
    - 定义推送接口实现类：PushServiceImpl，接口具体实现类，使用注解ServiceProvider标记
    - apt生成类：PushService接口委托类，ServiceRegistry


#### 4.7 SIP拓展原理
- SPI机制原理
    - 1.使用@ServiceProvider来标注该类提供哪些服务接口，标识服务的优先级与别名(加载时可通过别名指定加载某个服务)
    - 2.在构建过程中，java代码编译完成之后，执行自定义的gradle任务，扫描所有class，生成SPI配置文件，存放接口、接口实现类(服务)与实现类优先级信息
    - 3.解析SPI配置文件，通过Javapoet生成ServiceRegistry.java，将配置文件中接口与实现类的映射关系转译成代码，生成静态代码块可在类加载时自动完成 服务的注册
    - 4.把ServiceRegistry.java编译成class文件，被ClassLoader加载后可在ServiceLoader中正常引用完成服务的创建



遇到的问题
1.ServiceRegistry是如何解析生成该编译文件的，这块还要在熟悉下apt，找到项目中具体的实现代码分析下。
2.比如在PushService代码中，成员位置调用ServiceLoader.laod创建接口实现类对象，如果不是单利创建对象，那么会不会多次调用load创建多次对象？是否可以改成在静态final形式或者在静态代码块中调用？
SPI原理图

问题解答说明
1.如何扫描所有class？
写一个plugin插件，开启一个task任务，然后去加载代码文件目录或者jar，遍历取后缀名为.class的字节码并存储到list集合中。
2.委派代理的作用？
接口+接口实现类+接口委派类，调用的时候使用委派类，而具体的实现逻辑细节在实现类中。主要是起到代码隔离和解耦合的操作。
3.如何生成apt代码？

4.ServiceLoader.laod多次会怎样？
会创建多个对象。所以这个一般都是保持单利的形式
5.如何实现priority优先级？
首先获取ServiceProvider注解，然后通过注解拿到里面的参数。然后遍历所有被注解标记的类，最后把优先级写到file文件中。


### 参考
- 开发插件并发布到JitPack：https://www.jianshu.com/p/c78263dc3b7a
- JavaSPI机制学习笔记：https://www.cnblogs.com/lovesqcc/p/5229353.html
- 高级开发必须理解的Java中SPI机制：https://www.jianshu.com/p/46b42f7f593c
- https://www.jb51.net/article/205636.htm
- spi通信交互
    - https://github.com/luqinx/sp
    - https://juejin.cn/post/6872335132229894158