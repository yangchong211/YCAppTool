#### 目录介绍
- 01.线程优化的背景
- 02.线程使用的现状
    - 2.1 线程使用问题
    - 2.2 线程问题有哪些
    - 2.3 使用线程池管理线程
- 03.线程的一些基础
    - 3.1 主线程与子线程
    - 3.2 UI线程的特点
    - 3.3 如何理解多线程
    - 3.4 线程交互Handler
- 04.异步任务的方式
    - 4.1 Thread直接创建
    - 4.2 Thread+Looper+handler
    - 4.3 AsyncTask
    - 4.4 HandlerThread
    - 4.5 IntentService
    - 4.6 线程池Executors
- 05.高效的使用线程
    - 5.1 多线程安全问题
    - 5.2 
- 06.合理设置线程优先级
    - 6.1 设置线程优先级方式
- 07.线程卡顿是怎么回事
    - 7.1 线程如何卡顿
    - 7.2 如何模拟线程卡顿
    - 7.3 如何解决线程卡顿


### 01.线程优化的背景


### 02.线程使用的现状
#### 2.1 线程使用问题


#### 2.2 线程问题有哪些
- UI 线程如果阻塞，会导致界面卡顿、ANR 等问题。
    - 为了保证 UI 的流畅性，一些耗时的工作就不能在主线程中进行处理了，例如，网络操作、I/O 操作等。绝大多数，耗时操作都应该在子线程中处理。


#### 2.3 使用线程池管理线程
- 因为在系统中创建线程是一个比较耗费资源的事, 所以不能频繁创建和释放线程, 因此在效率上考虑通常会使用线程池, 同时也便于线程的管理。 Android中的AsyncTask就使用了线程池。


### 03.线程的一些基础
#### 3.1 Android中的线程
- 主线程(有的也成UI线程)
    - 在Android当中, 当应用启动的时候，系统会给应用分配一个进程，顺便一提，大部分应用都是单进程的，不过也可以通过设置来使不同组件运行在不同的进程中。
    - 在创建进程的同时会创建一个线程，应用的大部分操作都会在这个线程中运行。所以称为主线程，同时所有的UI控件相关的操作也要求在这个线程中操作，所以也称为UI线程。
- 为何会有子线程
    - 因为所有的UI控件的操作都在UI线程中执行，如果在UI线程中执行耗时操作，例如网络请求等，就会阻塞UI线程，导致系统报ANR(Application Not Response)错误。
    - 因此对于耗时操作需要创建工作线程来执行而不能直接在UI线程中执行。这样就需要在应用中使用多线程，但是Android提供的UI工具包并不是线程安全的，也就是说不能直接在工作线程中访问UI控件，否则会导致不能预测的问题， 因此需要额外的机制来进行线程交互，主要是让其他线程可以访问UI线程。





#### 3.2 UI线程的特点
- Android UI线程（主线程）有几个特点：
    - 只能在 UI 线程操作 UI 视图，不能在子线程中操作。
    - 不能在 UI 线程中进行耗时操作，否则会阻塞 UI 线程，引起 ANR、卡顿等问题。
- 在 Android 开发中，我们通常将一些耗时的操作使用异步任务的方式进行处理。
    - 例如这样一种这种场景，子线程在后台执行一个异步任务，任务过程中，需要 UI 进程展示进度，这时我们就需要一个工具来实现这种需求。
    - Android 系统为开发人员提供了一个异步任务类（AsyncTask）来实现上面所说的功能，即它会在一个子线程中执行计算任务，同时通过主线程的消息循环来获得更新应用程序界面的机会。


#### 3.4 线程交互Handler
- 在Android当中, 工作线程主要通过Handler机制来访问UI线程。
    - 当然还有一些封装好的类例如AsyncTask可以使用, 但是本质仍是使用Handler。
- Handler机制主要由4部分组成, Looper, 消息队列, 消息类和Handler组成。
    - 其中Looper和消息队列是和线程绑定的, 每个线程只会有一个Looper和一个消息队列, 当Looper启动时，它会无限循环尝试从消息队列中获取消息实例，如果没有消息则会阻塞等待。
    - 当Handler发送消息时会把消息实例放入消息队列中，Looper从中取得消息实例然后就会调用Handler的相关方法，因为Looper是线程绑定的, 如果绑定的是UI线程，那么此时Handler的方法就会在UI线程中得到执行，线程间就是这样进行交互的。



### 04.异步任务的方式
#### 4.1 Thread直接创建
- 最直接的方式，就是使用 Java 提供的 Thread 类进行线程创建，从而实现异步。
- 遇到的问题有哪些？
    - 继承Thread，或者实现接口Runnable来开启一个子线程，无法准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。当线程出现异常的时候，如何避免导致崩溃问题？
= 开启Thread线程案例如下
    - **一般开启线程的操作如下所示**
        ``` 
        new Thread(new Runnable() {
            @Override
            public void run() {
                //做一些任务
            }
        }).start();
        ``` 
    - 分析
        - 创建了一个线程并执行，它在任务结束后GC会自动回收该线程。
        - 在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕。
- **主要的弊端有这些**
    - 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM
    - 使用start()方法启动线程，该线程会在run()方法结束后，自动回收该线程。虽然如此，在某些场景中线程业务的处理速度完全达不到我们的要求，系统中的线程会逐渐变大，进而消耗CPU资源，大量的线程抢占宝贵的内存资源，可能还会出现OOM，即便没有出现，大量的线程回收也会个GC带来很大的压力。
    - 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿
    - 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失



#### 4.2 Thread+Looper+handler
- Android 提供了 Handler 机制来进行线程之间的通信，我们可以使用 Android 最基础的异步方式：Thread + Looper + handler 来进行异步任务。
- 优点：
    - 操作简单，无学习成本。
- 缺点：
    - 代码规范性较差，不易维护。每次操作都会开启一个匿名线程，系统开销较大。
    - 多任务同时执行时不易精确控制线程。
- 使用范围：
    - 多个异步任务的更新UI



#### 4.3 AsyncTask
- 较为轻量级的异步类
    - 封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于后台与界面持续交互。便于执行后台任务以及在子线程中进行UI操作。
- 优点：
    - 结构清晰，使用简单，适合后台任务的交互。
    - 异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。
- 缺点：
    - 结构略复杂，代码较多。每个 AsyncTask 只能被执行一次，多次调用会发生异常。
    - AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。
- 使用范围
    - 单个异步任务的处理



#### 4.4 HandlerThread
- HandlerThread 是一个自带 Looper 消息循环的线程类。
    - 处理异步任务的方式和 Thread + Looper + Handler 方式相同。
- 优点：
    - 简单，内部实现了普通线程的 Looper 消息循环。可以串行执行多个任务。
    - 内部拥有自己的消息队列，不会阻塞 UI 线程。
- 缺点：
    - 没有结果返回接口，需要自行处理。消息过多时，容易造成阻塞。
    - 只有一个线程处理，效率较低。线程优先级默认优先级为 THREAD_PRIORITY_DEFAULT，容易和 UI 线程抢占资源。



#### 4.5 IntentService
- IntentService 继承自 Service 类。
    - 用于启动一个异步服务任务，它的内部是通过 HandlerThread 来实现异步处理任务的。是一种异步、会自动停止的服务。
- 优点：
    - 只需要继承 IntentService，就可以在 onHandlerIntent 方法中异步处理 Intent 类型任务了。
    - 任务结束后 IntentService 会自行停止，无需手动调用 stopService。
    - 可以执行处理多个 Intent 请求，顺序执行多任务。
    - IntentService 是继承自 Service，具有后台 Service 的优先级。
- 缺点：
    - 需要启动服务来执行异步任务，不适合简单任务处理。
    - 异步任务是由 HandlerThread 实现的，只能单线程、顺序处理任务。
    - 没有返回 UI 线程的接口。


### 4.6 线程池Executors
- 利用 Executors 的静态方法创建多线程
    - java当中主要使用Thread和Executor来实现多线程. Thread用于直接创建线程, 在Android中也可以直接使用这个类, Looper中就包含一个Thread实例. Executor是一个接口, 大部分java中自带的实现都使用了线程池来管理多线程。
    - newCachedThreadPool()、newFixedThreadPool()、newSingleThreadExecutor() 及重载形式实例化 ExecutorService 接口即得到线程池对象。
- 优点：
    - 线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。
    - 适合执行大量异步任务，提高性能。
    - 灵活性高，可以自由控制线程数量。
    - 扩展性好，可以根据实际需要进行扩展。
- 缺点：
    - 代码略显复杂。
    - 线程池本身对系统资源有一定消耗。
    - 当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。
    - 每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。
    - 线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。



### 05.高效的使用线程
#### 5.1 多线程安全问题
- 线程安全问题
    - 使用多线程时需要注意的是线程安全的问题, 因为同一进程中的线程可以共享内存, 虽然这种方式效率很高, 但是会导致线程干扰和内存一致性的问题。[博客](https://github.com/yangchong211/YCBlogs)
- 锁机制
    - 解决这些问题的主要方法是使用Synchronized关键字来加锁. 基本原理就是线程要对对象进行操作前需要先获取锁, 如果一个线程正在操作某个对象, 那么它就会持有相应的锁, 后来的线程想要操作这个对象, 只能等待前面的线程释放锁之后才有机会获取锁并进行操作.



- 思考一些问题
    - 了解了如何创建线程，来执行异步任务，那么如果大量的使用线程，会不会影响 UI 线程呢？会不会产生卡顿呢?答案是肯定的。
    - 因为用户手机的 CPU 资源是有限的，内存也是有限的，如果无节制的同一时刻创建的大量的线程，就会导致线程和 UI 线程同时抢占 CPU 资源，造成 UI 线程执行变慢，产生卡顿等问题；
    - 并且线程创建是有代价的，线程不但占用了大量的 CPU 资源，同时也占用了大量的内存资源，Android 在真正创建线程时，会为每个线程申请 1040KB 的内存资源，大量的线程就有可能导致 OOM 等问题。
    - 另外，线程的创建和销毁也会占用系统资源来执行，所以应该合理的使用线程。
- 如何高效的使用线程
    - 将异步任务分类，根据任务的紧急程度，使用不同优先级的线程来执行。
    - 将紧急任务，交给优先级高的线程来执行，并且要注意，线程不能产生长时间阻塞，否则会影响后续任务的执行。
    - 将不紧急任务，交给低优先级线程来执行，并且控制线程数量，少量线程，慢慢执行即可。例如，可以创建一个类似于 AnsyncTask 的全局的单线程任务队列，使用 1 个线程来执行一些不紧急的任务。
    - 使用线程池来优化线程的创建和管理线程。我们可以使用线程池来全局的管理线程的创建和执行，以此来避免频繁的线程创建和销毁，提高系统的性能。
    - 不要使用默认的线程优先级。通常，新创建的线程的线程优先级，默认情况下继承了父线程的线程优先级的，例如，在 UI 线程中创建了一个子线程，那么子线程的线程优先级就和 UI 线程是相同的。
    - 尽可能的将线程优先级级别设置的低一些，以避免子线程和 UI 线程竞争 CPU 资源。
    - 设置线程优先级时，应注意线程优先级的设置方法。




### 06.合理设置线程优先级
#### 6.1 设置线程优先级方式
- 在 Android 中，有两种常见的设置线程优先级的方式：
    - 第一种，使用 Thread 类实例的 setPriority 方法，来设置线程优先级。
    - 第二种，使用 Process 类的 setThreadPriority 方法，来设置线程优先级。
- 这两种设置线程的优先级，一种是 Java 原生版本，另一种是 Android API 版本。
    - 这两种方式是不同的，Android 更推荐使用第二种方式。
- https://blog.csdn.net/u011578734/article/details/110549238


### 07.线程卡顿是怎么回事




