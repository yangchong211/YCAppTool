# App重启操作库
#### 目录介绍
- 01.基础概念介绍
- 02.常见思路做法
- 03.Api调用说明
- 04.遇到的坑分析
- 05.该库性能分析



### 01.基础概念介绍
#### 1.1 业务背景介绍
- 在App开发过程中，经常需要自动重启的功能。比如：
    - 登录或登出的时候，为了清除缓存的一些变量，比较简单的方法就是重新启动app。
    - crash的时候，可以捕获到异常，直接自动重启应用。
    - 在一些debug的场景中，比如设置了一些测试的标记位，需要重启才能生效，此时可以用自动重启，方便测试。
- 还有一些特殊的场景，比如一些硬件设备：
    - 由于App是launcher应用，长期运行在硬件设备上，除了做内存优化之外。有时候需要在夜间某时间重启，可以解决一些体验上问题！


#### 1.2 崩溃重启原理



### 02.常见思路和做法
#### 2.1 使用背景说明
- 一个简单的应用场景：
    - App可以提供多种不同重新启动应用的方式（如使用闹钟重启、延迟服务重启、清单文件方式重启等）.
    - 这些不同重启方式都源自同一个基类，继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的方式。
- 使用工厂模式
    - 如果希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。


#### 2.2 崩溃重启方式
- 方式1: AlarmManager
    - 使用AlarmManager实现自动重启的核心思想：创建一个100ms之后的Alarm任务，等Alarm任务到执行时间了，会自动唤醒App。
    - 缺点：在App被杀和拉起之间，会显示系统Launcher桌面，体验不好。在高版本不适用
- 方式2: 直接启动Activity
    - 缺点：MainActivity必须是Standard模式
- 方式3: 启动新进程开启应用
    - 简单来说，当调用重启app后进入首页方法的时候，会启动一个透明的Activity，这个Activity运行在:reboot 进程
    - Activity启动后，杀掉主进程，然后用:reboot 进程拉起主进程的Activity。关闭当前Activity，杀掉:reboot 进程



#### 2.3 新进程开启应用原理
- 新进程开启应用原理大概如下所示，可以做到无缝启动应用！
    - 启动一个新的进程。相当于通过intent开启一个透明的activity，并且给它开启一个独立的进程。
    - 杀掉主进程。在这个透明的activity中，杀死原来的主进程。
    - 用新的进程，重新拉起主进程。然后拿到要启动的intent，其实这个就是清单文件配置默认启动activity的intent。
    - 杀掉新的进程。最后通过Runtime杀死主进程！




#### 2.4 模式结构设计
- Factory：工厂角色。工厂角色负责实现创建所有实例的内部逻辑
- Product：抽象产品角色。抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- ConcreteProduct：具体产品角色。具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。




### 03.Api调用说明
- 第一种方式，开启一个新的服务KillSelfService，用来重启本APP。
    ``` java
    RestartAppHelper.restartApp(this,RestartFactory.SERVICE);
    ```
- 第二种方式，使用闹钟延时，使用PendingIntent延迟意图，然后重启app
    ``` java
    RestartAppHelper.restartApp(this,RestartFactory.ALARM);
    ```
- 第三种方式，检索获取项目中LauncherActivity，然后设置该activity的flag和component启动app
    ``` java
    RestartAppHelper.restartApp(this,RestartFactory.MAINIFEST);
    ```



### 04.遇到的坑分析
#### 4.1 新进程开启应用注意
- 因为开启了新进程，导致初始化多次
    - 通常会在Application的onCreate方法中做一系列初始化的操作。
    - 如果使用reboot库，需要在onCreate方法中判断，如果当前进程是reboot进程，则直接return，跳过初始化的操作。
- 如下所示：
    ```
    if (RebootManager.getInstance().isRebootProcess(this)) {
        return;
    }
    ```



### 05.该库性能分析
#### 5.1 为何使用简单工厂
- 通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。








