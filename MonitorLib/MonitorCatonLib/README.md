# 卡顿检测和捕获
#### 目录介绍
- 01.基础概念介绍
- 02.LooperPrinter监控
- 03.WatchDog卡顿监控
- 03.Api调用说明
- 04.遇到的坑分析
- 05.其他问题说明



### 01.基础概念说明
#### 1.1 核心思路
- 每次Message处理(也就是dispatchMessage(msg))都会在处理前，和处理后通过Looper.mLogging打印日志。
- 只需知道打印日志的时间差即可知道Message的处理耗时。当耗时超过我们的阈值时我们即可收集调用堆栈，然后根据堆栈进行针对性优化即可。


### 02.LooperPrinter监控
#### 2.1 使用LooperPrinter监控
- 卡顿监控不优雅的处理
    - 直接创建一个基类放在我们的项目代码中，所有需要Handler的地方都对此进行继承，然后我们在基类中添加日志监控，这样就可以实现我们的目的了吧？
    - 不好，这样对项目改造的成本太高了，而且我们也监控不到系统中的消息，也监控不到第三方sdk中的消息执行时间！
- 卡顿监控优雅的处理
    - 分析Looper中的loop方法可知，处理消息前后有日志打印，看到有个Printer日志输出管理的类，并且暴露setMessageLogging方法。这个可以自己定义实现。
- 使用LooperPrinter监控
    - 替换主线程Looper的Printer，从而监控dispatchMessage的执行时间。甚至，在Android源码中，主线程Looper也会根据执行dispatchMessage的时间来判断是否有卡顿，有则会打印一些日志。
    - 在Printer中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。
    - 卡顿之后收集相关dump信息，主要包含一些基本信息，耗时信息，CPU信息还有堆栈信息等等。可以直接参考LeakCanary即可。
- Printer监控优缺点
    - 优点：不会随机漏报，无需轮询，一劳永逸；缺点：某些类型的卡顿无法被监控到



### 03.WatchDog卡顿监控
#### 3.1 WatchDog卡顿监控
- 如何监控UI卡顿
    - 启动一个卡顿检测线程，该线程定期的向UI线程发送一条延迟消息，执行一个标志位加1的操作，如果规定时间内，标志位没有变化，则表示产生了卡顿。如果发生了变化，则代表没有长时间卡顿，我们重新执行延迟消息即可。
- 具体的原理说明
    - 具体的原理和实现方法很简单：不断向UI线程发送Message，每隔一段时间检查一次刚刚发送的Message是否被处理，如果没有被处理，则说明这段时间主线程被卡住了。


#### 3.2 WatchDog的优缺点
- 优缺点
    - 优点：简单，稳定，结果论，可以监控到各种类型的卡顿
    - 缺点：轮询不优雅，不环保，有不确定性，随机漏报
- 间隔时间设置
    - 这种方法的轮询的时间间隔选择很重要，又让人左右为难，轮询的时间间隔越小，对性能的负面影响就越大，而时间间隔选择的越大，漏报的可能性也就越大。
- 如何理解性能负面影响
    - 前者很容易理解，UI线程要不断处理我们发送的Message，必然会影响性能和功耗。


#### 3.3 如何理解漏报数据
- 时间间隔选择了4秒
    - 事实上，之前是想要通过这种方案来监控ANR，当然，这并不严谨。来分析一下
- 举一个例子
    - 每隔4秒，向主线程发送一个消息。下面是轮训的过程
    - 0秒 ---- 4秒 ---- 8秒 ---- 12秒 ---- 16秒
    - 现在有一个5秒的卡顿发生在第2秒，结束在第7秒，这种情况无论是在0-4秒的周期内，还是4-8秒的周期内，都有一段时间是不卡顿的，消息都可以被处理掉，这种情况自然就无法被监控到。
- 计算监控成功率
    - 计算公式：p = x/a - 1 ；注意条件（a<= x <= 2a）
    - 上面案例计算 ： p = 5/4 - 1 = 0.25 ; 如果轮询间隔设置为4秒，发现一个5秒的卡顿的概率仅为25%。
- 修改轮训间隔时间
    - 默认轮询间隔为5秒，如果有一个8秒的卡顿（8秒已经很容易产生ANR），被发现的概率也只有8/5-1=60%
    - 从这个概率公式还可以发现，对于一个固定的轮询间隔，只有卡顿时间大于两倍的轮询间隔，才能百分之百被监控到。
- 思考把间隔时间缩短
    - 每隔2秒，向主线程发送一个消息。下面是轮训的过程
    - 0秒 -- 2秒 -- 4秒 -- 6秒 -- 8秒 -- 10秒 -- 12秒
    - 现在有一个6秒的卡顿发生在第1秒，结束在第7秒，那么这个在在2-4，和4-6区间可以捕获到。




### 03.Api调用说明



### 04.遇到的坑分析


### 05.其他问题说明
#### 5.1 该库存在弊端
- 1.View的TouchEvent事件是在queue.next()中处理的，只统计dispatchMessage(msg)前后耗时，不会覆盖到View的TouchEvent耗时。
- 2.IdleHandler.queueIdle()也在queue.next()中，当主线程空闲会调用IdleHandler，此时IdleHandler也是在主线程执行，当过于耗时时也可能出现卡顿，甚至到只ANR，这种场景也无法监控。
- 3.SyncBarrier（同步屏障）的泄漏同样无法被监控到，这种情况比较少见，参考了微信的监控方案。



### 参考博客


